if not game:IsLoaded() then
  game.Loaded:Wait()
end

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local localPlayer = Players.LocalPlayer

local player = Players.LocalPlayer

if _G.KinayoScriptsLoaded then
    return
end

_G.KinayoScriptsLoaded = true

local HttpService = game:GetService("HttpService")

local onMessage = function(message)
  game:GetService("StarterGui"):SetCore("SendNotification", {
      Title = "Status",
      Text = message
  })
end

local API_URL = "https://kinayo8.pythonanywhere.com"
local fRequest = request or http_request or syn_request

local function getHWID()
    return gethwid()
end

local function getScaleFactor()
    local viewportSize = workspace.CurrentCamera.ViewportSize
    local baseScale = math.clamp(math.min(viewportSize.X/1920, viewportSize.Y/1080), 0.8, 1.5)
    return baseScale * 1.2
end

local scaleFactor = getScaleFactor()

local discordLink = "https://discord.gg/SdWZ9srXJe"

local Players = game:GetService("Players")
local Player = Players.LocalPlayer

local gameName = "Dungeon Quest"

if not isfolder("kinayosave") then
    makefolder("kinayosave")
end

local KeySystemGui = Instance.new("ScreenGui")
KeySystemGui.Name = "KeySystem"
KeySystemGui.Parent = Player.PlayerGui
KeySystemGui.DisplayOrder = 999999999
KeySystemGui.ResetOnSpawn = false

local KeyFrame = Instance.new("ImageLabel")
KeyFrame.Name = "KeyFrame"
KeyFrame.Size = UDim2.new(0, 200, 0, 150)
KeyFrame.AnchorPoint = Vector2.new(0.5, 0.5)
KeyFrame.Position = UDim2.new(0.5, 0, 0.5, 0) 
KeyFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
KeyFrame.BackgroundTransparency = 0.4
KeyFrame.ImageTransparency = 0.5
KeyFrame.BorderSizePixel = 0
KeyFrame.Image = "rbxassetid://9240529838"
KeyFrame.ScaleType = Enum.ScaleType.Stretch
KeyFrame.Parent = KeySystemGui

local keyUIScale = Instance.new("UIScale")
keyUIScale.Scale = scaleFactor
keyUIScale.Parent = KeyFrame

local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 12)
UICorner.Parent = KeyFrame

local UIStroke = Instance.new("UIStroke") 
UIStroke.Color = Color3.fromRGB(147, 112, 219)
UIStroke.Thickness = 2
UIStroke.Parent = KeyFrame

local function HSVtoRGB(h, s, v)
    local r, g, b
    
    local i = math.floor(h * 6)
    local f = h * 6 - i
    local p = v * (1 - s)
    local q = v * (1 - f * s)
    local t = v * (1 - (1 - f) * s)
    
    i = i % 6
    
    if i == 0 then r, g, b = v, t, p
    elseif i == 1 then r, g, b = q, v, p
    elseif i == 2 then r, g, b = p, v, t
    elseif i == 3 then r, g, b = p, q, v
    elseif i == 4 then r, g, b = t, p, v
    elseif i == 5 then r, g, b = v, p, q
    end
    
    return Color3.new(r, g, b)
end

task.spawn(function()
    local hue = 0
    while true do
        if not KeyFrame or not KeyFrame.Parent then break end
        UIStroke.Color = HSVtoRGB(hue, 0.8, 1)
        hue = (hue + 0.005) % 1
        task.wait(0.03)
    end
end)

local Title = Instance.new("TextLabel")
Title.Name = "Title"
Title.Size = UDim2.new(1, 0, 0, 30)
Title.Position = UDim2.new(0, 0, 0, 0)
Title.BackgroundTransparency = 1
Title.Text = "Kinayo Key System"
Title.Font = Enum.Font.GothamBold
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextSize = 16
Title.Parent = KeyFrame

local KeyBox = Instance.new("TextBox")
KeyBox.Name = "KeyBox"
KeyBox.Size = UDim2.new(0.8, 0, 0, 25)
KeyBox.Position = UDim2.new(0.1, 0, 0.23, 0)
KeyBox.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
KeyBox.BackgroundTransparency = 0.5
KeyBox.Text = ""
KeyBox.PlaceholderText = "Enter Key"
KeyBox.TextColor3 = Color3.fromRGB(255, 255, 255)
KeyBox.Font = Enum.Font.Gotham
KeyBox.TextSize = 14
KeyBox.Parent = KeyFrame

local UICorner_2 = Instance.new("UICorner")
UICorner_2.CornerRadius = UDim.new(0, 8)
UICorner_2.Parent = KeyBox

local DiscordButton = Instance.new("TextButton")
DiscordButton.Name = "DiscordButton"
DiscordButton.Size = UDim2.new(0.8, 0, 0, 25)
DiscordButton.Position = UDim2.new(0.1, 0, 0.42, 0)
DiscordButton.BackgroundColor3 = Color3.fromRGB(88, 101, 242)
DiscordButton.BackgroundTransparency = 0.2
DiscordButton.Text = "Copy Discord"
DiscordButton.Font = Enum.Font.Gotham
DiscordButton.TextColor3 = Color3.fromRGB(255, 255, 255)
DiscordButton.TextSize = 14
DiscordButton.Parent = KeyFrame

local UICorner_3 = Instance.new("UICorner")
UICorner_3.CornerRadius = UDim.new(0, 8)
UICorner_3.Parent = DiscordButton

local ResetHWIDButton = Instance.new("TextButton")
ResetHWIDButton.Name = "ResetHWIDButton" 
ResetHWIDButton.Size = UDim2.new(0.8, 0, 0, 25)
ResetHWIDButton.Position = UDim2.new(0.1, 0, 0.61, 0)
ResetHWIDButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
ResetHWIDButton.BackgroundTransparency = 0.6
ResetHWIDButton.Text = "Reset HWID"
ResetHWIDButton.Font = Enum.Font.Gotham
ResetHWIDButton.TextColor3 = Color3.fromRGB(255, 255, 255)
ResetHWIDButton.TextSize = 14
ResetHWIDButton.Parent = KeyFrame

local UICorner_5 = Instance.new("UICorner")
UICorner_5.CornerRadius = UDim.new(0, 8)
UICorner_5.Parent = ResetHWIDButton

local VerifyButton = Instance.new("TextButton")
VerifyButton.Name = "VerifyButton"
VerifyButton.Size = UDim2.new(0.8, 0, 0, 25)
VerifyButton.Position = UDim2.new(0.1, 0, 0.8, 0)
VerifyButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
VerifyButton.BackgroundTransparency = 0.6
VerifyButton.Text = "Verify Key"
VerifyButton.Font = Enum.Font.Gotham
VerifyButton.TextColor3 = Color3.fromRGB(255, 255, 255)
VerifyButton.TextSize = 14
VerifyButton.Parent = KeyFrame

local UICorner_4 = Instance.new("UICorner")
UICorner_4.CornerRadius = UDim.new(0, 8)
UICorner_4.Parent = VerifyButton

DiscordButton.MouseButton1Click:Connect(function()
   DiscordButton.BackgroundColor3 = Color3.fromRGB(120, 130, 255)
   setclipboard(discordLink)
   onMessage("Discord link copied!")
   task.wait(0.1)
   DiscordButton.BackgroundColor3 = Color3.fromRGB(88, 101, 242)
end)

ResetHWIDButton.MouseButton1Click:Connect(function()
   ResetHWIDButton.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
   onMessage("To reset your key, you need to open a HWID reset ticket in the official Discord channel!")
   task.wait(0.1)
   ResetHWIDButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
end)

local function createDiscordButton(parent, position)
    local discordButton = Instance.new("TextButton")
    discordButton.Size = UDim2.new(0, 40, 0, 20)
    discordButton.Position = position
    discordButton.BackgroundColor3 = Color3.fromRGB(114, 137, 218)
    discordButton.Text = "Discord"
    discordButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    discordButton.Font = Enum.Font.GothamBold
    discordButton.TextSize = 12
    discordButton.BackgroundTransparency = 0.5
    discordButton.Parent = parent

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 5)
    corner.Parent = discordButton

    discordButton.MouseButton1Click:Connect(function()
        setclipboard(discordLink)
        showNotification("Discord", "Discord invite link copied to clipboard", 3)
    end)

    return discordButton
end

local function createResetButton(parent, position)
    local resetButton = Instance.new("TextButton")
    resetButton.Size = UDim2.new(0, 40, 0, 20)
    resetButton.Position = position
    resetButton.BackgroundColor3 = Color3.fromRGB(220, 53, 69)
    resetButton.Text = "Reset"
    resetButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    resetButton.Font = Enum.Font.GothamBold
    resetButton.TextSize = 12
    resetButton.BackgroundTransparency = 0.5
    resetButton.Parent = parent

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 5)
    corner.Parent = resetButton

    return resetButton
end

local function showNotification(title, text, duration)
    StarterGui:SetCore("SendNotification", {Title = title, Text = text, Duration = duration or 5})
end

local function getRandomBackgroundImageId()
    local imageIds = {
        "15864494545", 
        "14196530715", 
        "14475650159", 
        "14020362767"
    }
    return "rbxassetid://" .. imageIds[math.random(1, #imageIds)]
end

local ScreenGui = Instance.new("ScreenGui")
local MainFrame = Instance.new("Frame")
local MapButton = Instance.new("TextButton")
local DifficultyButton = Instance.new("TextButton")
local TierButton = Instance.new("TextButton")
local StartButton = Instance.new("TextButton")
local HardcoreButton = Instance.new("TextButton")
local CharacterButton = Instance.new("TextButton")
local ScrollingMapFrame = Instance.new("ScrollingFrame")
local DifficultyFrame = Instance.new("Frame")
local TierFrame = Instance.new("Frame")
local CharacterFrame = Instance.new("Frame")
local HostInput = Instance.new("TextBox")
local AltInput = Instance.new("TextBox")

local function loadMainScript()
  KeySystemGui:Destroy()

ScreenGui.ResetOnSpawn = false
ScreenGui.DisplayOrder = 9999999

local isTeleporting = false
local isHardcore = false
local selectedMap = ""
local selectedDifficulty = ""
local selectedTier = 1
local selectedCharacter = 1
local desiredPlaceID = 2414851778

HostInput.Size = UDim2.new(0.4, 0, 0.15, 0)
HostInput.Position = UDim2.new(0.05, 0, 0.65, 0)
HostInput.Text = ""
HostInput.TextSize = 8
HostInput.PlaceholderText = "Enter host"
HostInput.Parent = MainFrame
HostInput.TextColor3 = Color3.fromRGB(255, 255, 255)
HostInput.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
HostInput.ClearTextOnFocus = false

AltInput.Size = UDim2.new(0.4, 0, 0.15, 0)
AltInput.Position = UDim2.new(0.55, 0, 0.65, 0)
AltInput.Text = ""
AltInput.TextSize = 8
AltInput.PlaceholderText = "Alt accounts (space-separated)"
AltInput.Parent = MainFrame
AltInput.TextColor3 = Color3.fromRGB(255, 255, 255)
AltInput.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
AltInput.ClearTextOnFocus = false

local function saveSettings()
    local saveFolder = "kisave"
    if not isfolder(saveFolder) then
        makefolder(saveFolder)
    end
    
    writefile(saveFolder .. "/autoform_settings.txt", game:GetService("HttpService"):JSONEncode({
        teleporting = isTeleporting,
        map = selectedMap,
        difficulty = selectedDifficulty,
        tier = selectedTier,
        hardcore = isHardcore,
        character = selectedCharacter,
        host = HostInput.Text,
        alts = AltInput.Text
    }))
end

local function loadSettings()
    local saveFolder = "kisave"
    local fileName = saveFolder .. "/autoform_settings.txt"
    
    if isfolder(saveFolder) and isfile(fileName) then
        local data = game:GetService("HttpService"):JSONDecode(readfile(fileName))
        isTeleporting = data.teleporting
        selectedMap = data.map
        selectedDifficulty = data.difficulty
        selectedTier = data.tier or 1
        isHardcore = data.hardcore or false
        selectedCharacter = data.character or 1
        HostInput.Text = data.host or ""
        AltInput.Text = data.alts or ""
        
        if selectedMap ~= "" then
            MapButton.Text = selectedMap
        end
        if selectedDifficulty ~= "" then
            DifficultyButton.Text = selectedDifficulty
        end
        CharacterButton.Text = "Character: " .. selectedCharacter
        TierButton.Text = "Tier: " .. selectedTier
        StartButton.BackgroundColor3 = isTeleporting and Color3.fromRGB(85, 125, 255) or Color3.fromRGB(40, 40, 40)
        HardcoreButton.BackgroundColor3 = isHardcore and Color3.fromRGB(85, 125, 255) or Color3.fromRGB(40, 40, 40)
        StartButton.BackgroundTransparency = 0.4
        
        if isTeleporting then
            teleportLoop()
        end
    end
end

local function applyUIStyle(instance)
    instance.BorderSizePixel = 0
    instance.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
    
    local UICorner = Instance.new("UICorner")
    UICorner.CornerRadius = UDim.new(0, 8)
    UICorner.Parent = instance
    
    if instance:IsA("TextButton") then
        instance.Font = Enum.Font.GothamSemibold
        instance.TextColor3 = Color3.fromRGB(255, 255, 255)
        instance.TextSize = 14
        instance.BackgroundTransparency = 0.4
    end
end

MainFrame.Size = UDim2.new(0, 180, 0, 210)
MainFrame.Position = UDim2.new(0.8, -100, 0.4, -105)
MainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
MainFrame.BackgroundTransparency = 0.4
MainFrame.Visible = false

ScrollingMapFrame.Size = UDim2.new(1, 0, 1, 0)
ScrollingMapFrame.Position = UDim2.new(0, 0, 0, 0)
ScrollingMapFrame.BackgroundTransparency = 0.4
ScrollingMapFrame.Visible = false
ScrollingMapFrame.Parent = MainFrame
ScrollingMapFrame.ScrollBarThickness = 4
ScrollingMapFrame.ZIndex = 2

DifficultyFrame.Size = UDim2.new(1, 0, 1, 0)
DifficultyFrame.Position = UDim2.new(0, 0, 0, 0)
DifficultyFrame.BackgroundTransparency = 0.4
DifficultyFrame.Visible = false
DifficultyFrame.Parent = MainFrame
DifficultyFrame.ZIndex = 2

TierFrame.Size = UDim2.new(1, 0, 1, 0)
TierFrame.Position = UDim2.new(0, 0, 0, 0)
TierFrame.BackgroundTransparency = 0.4
TierFrame.Visible = false
TierFrame.Parent = MainFrame
TierFrame.ZIndex = 2

CharacterFrame.Size = UDim2.new(1, 0, 1, 0)
CharacterFrame.Position = UDim2.new(0, 0, 0, 0)
CharacterFrame.BackgroundTransparency = 0.4
CharacterFrame.Visible = false
CharacterFrame.Parent = MainFrame
CharacterFrame.ZIndex = 2

MapButton.Size = UDim2.new(0.4, 0, 0.15, 0)
MapButton.Position = UDim2.new(0.05, 0, 0.05, 0)
MapButton.Text = "Select Map"
MapButton.Parent = MainFrame

DifficultyButton.Size = UDim2.new(0.4, 0, 0.15, 0)
DifficultyButton.Position = UDim2.new(0.55, 0, 0.05, 0)
DifficultyButton.Text = "Select Difficulty"
DifficultyButton.Parent = MainFrame

CharacterButton.Size = UDim2.new(0.4, 0, 0.15, 0)
CharacterButton.Position = UDim2.new(0.05, 0, 0.25, 0)
CharacterButton.Text = "Character: 1"
CharacterButton.Parent = MainFrame

TierButton.Size = UDim2.new(0.4, 0, 0.15, 0)
TierButton.Position = UDim2.new(0.05, 0, 0.45, 0)
TierButton.Text = "Tier: 1"
TierButton.Parent = MainFrame

HardcoreButton.Size = UDim2.new(0.4, 0, 0.15, 0)
HardcoreButton.Position = UDim2.new(0.55, 0, 0.25, 0)
HardcoreButton.Text = "Hardcore"
HardcoreButton.Parent = MainFrame

StartButton.Size = UDim2.new(0.9, 0, 0.15, 0)
StartButton.Position = UDim2.new(0.05, 0, 0.85, 0)
StartButton.Text = "Start"
StartButton.Parent = MainFrame

local maps = {
    "Desert Temple", "Winter Outpost", "Pirate Island", "King's Castle",
    "The Underworld", "Samurai Palace", "The Canals", "Ghastly Harbor",
    "Steampunk Sewers", "Orbital Outpost", "Volcanic Chambers",
    "Aquatic Temple", "Enchanted Forest", "Northern Lands",
    "Gilded Skies", "Yokai Peak", "Abyssal Void", "Goliath Raid", "Hela Raid"
}

ScrollingMapFrame.CanvasSize = UDim2.new(0, 0, 0, #maps * 30)

for i, mapName in ipairs(maps) do
    local mapButton = Instance.new("TextButton")
    mapButton.Size = UDim2.new(0.9, 0, 0, 25)
    mapButton.Position = UDim2.new(0.05, 0, 0, (i-1) * 30)
    mapButton.Text = mapName
    mapButton.BackgroundTransparency = 0.4
    mapButton.Parent = ScrollingMapFrame
    mapButton.ZIndex = 2
    
    applyUIStyle(mapButton)
    
    mapButton.MouseButton1Click:Connect(function()
        selectedMap = mapName
        MapButton.Text = mapName
        ScrollingMapFrame.Visible = false
        saveSettings()
    end)
end

for i = 1, 5 do
    local tierButton = Instance.new("TextButton")
    tierButton.Size = UDim2.new(0.9, 0, 0.15, 0)
    tierButton.Position = UDim2.new(0.05, 0, 0.05 + (i-1) * 0.19, 0)
    tierButton.Text = "Tier " .. i
    tierButton.Parent = TierFrame
    tierButton.ZIndex = 2
    applyUIStyle(tierButton)
    
    tierButton.MouseButton1Click:Connect(function()
        selectedTier = i
        TierButton.Text = "Tier: " .. i
        TierFrame.Visible = false
        saveSettings()
    end)
end

for i = 1, 3 do
    local charButton = Instance.new("TextButton")
    charButton.Size = UDim2.new(0.9, 0, 0.15, 0)
    charButton.Position = UDim2.new(0.05, 0, 0.05 + (i-1) * 0.19, 0)
    charButton.Text = "Character " .. i
    charButton.Parent = CharacterFrame
    charButton.ZIndex = 2
    applyUIStyle(charButton)
    
    charButton.MouseButton1Click:Connect(function()
        selectedCharacter = i
        CharacterButton.Text = "Character: " .. i
        CharacterFrame.Visible = false
        saveSettings()
    end)
end

local NightmareButton = Instance.new("TextButton")
NightmareButton.Size = UDim2.new(0.9, 0, 0.45, 0)
NightmareButton.Position = UDim2.new(0.05, 0, 0.05, 0)
NightmareButton.Text = "Nightmare"
NightmareButton.BackgroundTransparency = 0.4
NightmareButton.Parent = DifficultyFrame
NightmareButton.ZIndex = 2

local InsaneButton = Instance.new("TextButton")
InsaneButton.Size = UDim2.new(0.9, 0, 0.45, 0)
InsaneButton.Position = UDim2.new(0.05, 0, 0.5, 0)
InsaneButton.Text = "Insane"
InsaneButton.BackgroundTransparency = 0.4
InsaneButton.Parent = DifficultyFrame
InsaneButton.ZIndex = 2

function CheckJoin()
    if game.Players.LocalPlayer.Name ~= _G.host then
        while not workspace.games.inLobby:FindFirstChild(_G.host) do
            wait()
        end
        while wait(.1) do
            game:GetService("ReplicatedStorage").remotes.joinDungeon:InvokeServer(_G.host)
        end
    else
        Create()
    end
end

function Create()
    game:GetService("ReplicatedStorage"):WaitForChild("remotes"):WaitForChild("createLobby"):InvokeServer(_G.Dungeon, _G.Difficult, 0, _G.Hardcore, false, false)
    wait(5)
    while (#(workspace.games.inLobby:FindFirstChild(game.Players.LocalPlayer.Name):GetChildren()) - 1) ~= (#_G.Alt + 1) do
        wait()
    end
    game:GetService("ReplicatedStorage"):WaitForChild("remotes"):WaitForChild("startDungeon"):FireServer()
    game:GetService("ReplicatedStorage"):WaitForChild("remotes"):WaitForChild("startDungeon"):FireServer()
end

local function startDungeon()
    
    task.spawn(function()
    local TeleportService = game:GetService("TeleportService")
    local HttpService = game:GetService("HttpService")
    local Players = game:GetService("Players")

    local TARGET_PLACE_ID = 2414851778
    local WAIT_TIME = 20

    local function getAvailableServer()
        local url = ("https://games.roblox.com/v1/games/%s/servers/Public?sortOrder=Asc&limit=100"):format(TARGET_PLACE_ID)
        local success, result = pcall(function()
            return HttpService:JSONDecode(game:HttpGet(url))
        end)
        
        if success and result and result.data then
            for _, server in ipairs(result.data) do
                if server.playing < server.maxPlayers and server.id ~= game.JobId then
                    return server.id
                end
            end
        end
        
        return nil
    end

    local function tryServerHop()
        local newServerId = getAvailableServer()
        if newServerId then
            TeleportService:TeleportToPlaceInstance(TARGET_PLACE_ID, newServerId, Players.LocalPlayer)
        end
    end

    if game.PlaceId == TARGET_PLACE_ID then
        task.wait(WAIT_TIME)
        tryServerHop()
    end
end)
    
    if HostInput.Text ~= "" and AltInput.Text ~= "" then
        _G.Dungeon = selectedMap
        _G.Difficult = selectedDifficulty
        _G.Hardcore = isHardcore
        _G.host = HostInput.Text
        _G.Alt = {}
        
        for alt in AltInput.Text:gmatch("%S+") do
            table.insert(_G.Alt, alt)
        end
        
        if game.PlaceId == 14363263080 then
            return
        else
            CheckJoin()
        end
    else
        if selectedMap ~= "" and selectedDifficulty ~= "" then
            local firstSymbols = {"5"}
            
            for _, firstSymbol in ipairs(firstSymbols) do
                local args1 = {
                    [1] = {
                        [1] = {
                            [1] = "\001"
                        },
                        [2] = firstSymbol
                    }
                }
                game:GetService("ReplicatedStorage").dataRemoteEvent:FireServer(unpack(args1))
                
                wait(1.5)
            end
            
            local symbols = {"M", "\152"}
            
            for _, symbol in ipairs(symbols) do
                local args2 = {
                    [1] = {
                        [1] = {
                            [1] = "\001",
                            [2] = {
                                ["characterIndex"] = selectedCharacter,
                                ["\003"] = "select"
                            }
                        },
                        [2] = symbol
                    }
                }
                game:GetService("ReplicatedStorage").dataRemoteEvent:FireServer(unpack(args2))
                
                wait(1.5)
            end
            
            local endSymbols = {"d", "\175"}
            
            for _, endSymbol in ipairs(endSymbols) do
                local args3 = {
                    [1] = {
                        [1] = {
                            [1] = "\001",
                            [2] = {
                                partyData = {
                                    difficulty = selectedDifficulty,
                                    mode = isHardcore and "Hardcore" or "Normal",
                                    dungeonName = selectedMap,
                                    tier = selectedTier
                                },
                                ["\003"] = "PlaySolo"
                            }
                        },
                        [2] = endSymbol
                    }
                }
                game:GetService("ReplicatedStorage").dataRemoteEvent:FireServer(unpack(args3))
                wait(1.5)
            end
        end
    end
end

function teleportLoop()
    spawn(function()
        while isTeleporting do
            startDungeon()
            wait(1.5)
        end
    end)
end

MapButton.MouseButton1Click:Connect(function()
    ScrollingMapFrame.Visible = true
    DifficultyFrame.Visible = false
    TierFrame.Visible = false
    CharacterFrame.Visible = false
end)

DifficultyButton.MouseButton1Click:Connect(function()
    DifficultyFrame.Visible = true
    ScrollingMapFrame.Visible = false
    TierFrame.Visible = false
    CharacterFrame.Visible = false
end)

TierButton.MouseButton1Click:Connect(function()
    TierFrame.Visible = true
    ScrollingMapFrame.Visible = false
    DifficultyFrame.Visible = false
    CharacterFrame.Visible = false
end)

CharacterButton.MouseButton1Click:Connect(function()
    CharacterFrame.Visible = true
    ScrollingMapFrame.Visible = false
    DifficultyFrame.Visible = false
    TierFrame.Visible = false
end)

NightmareButton.MouseButton1Click:Connect(function()
    selectedDifficulty = "Nightmare"
    DifficultyButton.Text = "Nightmare"
    DifficultyFrame.Visible = false
    saveSettings()
end)

InsaneButton.MouseButton1Click:Connect(function()
    selectedDifficulty = "Insane"
    DifficultyButton.Text = "Insane"
    DifficultyFrame.Visible = false
    saveSettings()
end)

HardcoreButton.MouseButton1Click:Connect(function()
    isHardcore = not isHardcore
    HardcoreButton.BackgroundColor3 = isHardcore and Color3.fromRGB(85, 125, 255) or Color3.fromRGB(40, 40, 40)
    saveSettings()
end)

StartButton.MouseButton1Click:Connect(function()
    isTeleporting = not isTeleporting
    StartButton.BackgroundColor3 = isTeleporting and Color3.fromRGB(85, 125, 255) or Color3.fromRGB(40, 40, 40)
    StartButton.BackgroundTransparency = 0.4
    saveSettings()
    
    if isTeleporting then
        teleportLoop()
    end
end)

applyUIStyle(MainFrame)
applyUIStyle(ScrollingMapFrame)
applyUIStyle(DifficultyFrame)
applyUIStyle(TierFrame)
applyUIStyle(CharacterFrame)
applyUIStyle(MapButton)
applyUIStyle(DifficultyButton)
applyUIStyle(TierButton)
applyUIStyle(CharacterButton)
applyUIStyle(StartButton)
applyUIStyle(HardcoreButton)
applyUIStyle(NightmareButton)
applyUIStyle(InsaneButton)
applyUIStyle(HostInput)
applyUIStyle(AltInput)

ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
MainFrame.Parent = ScreenGui
loadSettings()

local DisplayGui = Instance.new("ScreenGui")
local PrimaryFrame = Instance.new("Frame")
local SingleSellBtn = Instance.new("TextButton")
local LoopSellBtn = Instance.new("TextButton")
local CollectablesBtn = Instance.new("TextButton")

DisplayGui.ResetOnSpawn = false
DisplayGui.DisplayOrder = 9999999
DisplayGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

PrimaryFrame.Size = UDim2.new(0, 160, 0, 210)
PrimaryFrame.Position = UDim2.new(0.67, -80, 0.5, -105)
PrimaryFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
PrimaryFrame.BackgroundTransparency = 0.5
PrimaryFrame.BorderSizePixel = 0
PrimaryFrame.Parent = DisplayGui
PrimaryFrame.Visible = false

local FrameCorner = Instance.new("UICorner")
FrameCorner.CornerRadius = UDim.new(0, 8)
FrameCorner.Parent = PrimaryFrame

local categoryText = Instance.new("TextLabel")
categoryText.Position = UDim2.new(0, 10, 0, 8)
categoryText.Size = UDim2.new(1, -20, 0, 20)
categoryText.Text = "Select Item Types"
categoryText.BackgroundTransparency = 1
categoryText.TextColor3 = Color3.fromRGB(255, 255, 255)
categoryText.TextSize = 14
categoryText.Parent = PrimaryFrame

local selectedType = nil
local typeMenus = {}
local levelInputs = {}
local chosenRarities = {weapon = {}, ability = {}, chest = {}, helmet = {}, ring = {}}
local isLoopActive = false
local sellLoop = nil
local saveCollectables = false

local function isCollectable(levelReq)
    if not levelReq then return false end
    local levelStr = tostring(levelReq)
    return levelStr:sub(-1) == "6"
end

local function sellItems()
    local success, inventory = pcall(function()
        return game.ReplicatedStorage.remotes.reloadInvy:InvokeServer()
    end)
    
    if not success then return end
    
    for folderName, folder in pairs(inventory) do
        if folderName == "weapons" then
            for i, item in pairs(folder) do
                local levelThreshold = tonumber(levelInputs["weapon"].Text)
                local isCollectableItem = saveCollectables and isCollectable(item.levelReq)
                
                if not item.equipped and not item.favorite and item.isSellable ~= false and not isCollectableItem and (levelThreshold and (item.levelReq < levelThreshold or (item.levelReq == levelThreshold and chosenRarities.weapon[item.rarity])) or (not levelThreshold and chosenRarities.weapon[item.rarity])) then
                    local index = tonumber(string.sub(i, string.find(i, "_") + 1))
                    game:GetService("ReplicatedStorage").remotes.sellItemEvent:FireServer({["ability"] = {}, ["helmet"] = {}, ["chest"] = {}, ["weapon"] = {index}, ["ring"] = {}})
                end
            end
        elseif folderName == "chests" then
            for i, item in pairs(folder) do
                local levelThreshold = tonumber(levelInputs["chest"].Text)
                local isCollectableItem = saveCollectables and isCollectable(item.levelReq)
                
                if not item.equipped and not item.favorite and item.isSellable ~= false and not isCollectableItem and (levelThreshold and (item.levelReq < levelThreshold or (item.levelReq == levelThreshold and chosenRarities.chest[item.rarity])) or (not levelThreshold and chosenRarities.chest[item.rarity])) then
                    local index = tonumber(string.sub(i, string.find(i, "_") + 1))
                    game:GetService("ReplicatedStorage").remotes.sellItemEvent:FireServer({["ability"] = {}, ["helmet"] = {}, ["chest"] = {index}, ["weapon"] = {}, ["ring"] = {}})
                end
            end
        elseif folderName == "helmets" then
            for i, item in pairs(folder) do
                local levelThreshold = tonumber(levelInputs["helmet"].Text)
                local isCollectableItem = saveCollectables and isCollectable(item.levelReq)
                
                if not item.equipped and not item.favorite and item.isSellable ~= false and not isCollectableItem and (levelThreshold and (item.levelReq < levelThreshold or (item.levelReq == levelThreshold and chosenRarities.helmet[item.rarity])) or (not levelThreshold and chosenRarities.helmet[item.rarity])) then
                    local index = tonumber(string.sub(i, string.find(i, "_") + 1))
                    game:GetService("ReplicatedStorage").remotes.sellItemEvent:FireServer({["ability"] = {}, ["helmet"] = {index}, ["chest"] = {}, ["weapon"] = {}, ["ring"] = {}})
                end
            end
        elseif folderName == "rings" then
            for i, item in pairs(folder) do
                local levelThreshold = tonumber(levelInputs["ring"].Text)
                local isCollectableItem = saveCollectables and isCollectable(item.levelReq)
                
                if not (item.equipped.left1 or item.equipped.right1) and not item.favorite and item.isSellable ~= false and not isCollectableItem and (levelThreshold and (item.levelReq < levelThreshold or (item.levelReq == levelThreshold and chosenRarities.ring[item.rarity])) or (not levelThreshold and chosenRarities.ring[item.rarity])) then
                    local index = tonumber(string.sub(i, string.find(i, "_") + 1))
                    game:GetService("ReplicatedStorage").remotes.sellItemEvent:FireServer({["ability"] = {}, ["helmet"] = {}, ["chest"] = {}, ["weapon"] = {}, ["ring"] = {index}})
                end
            end
        elseif folderName == "abilities" then
            for i, item in pairs(folder) do
                local levelThreshold = tonumber(levelInputs["ability"].Text)
                local isCollectableItem = saveCollectables and isCollectable(item.levelReq)
                
                if not item.equipped and not item.favorite and item.isSellable ~= false and not isCollectableItem and (levelThreshold and (item.levelReq < levelThreshold or (item.levelReq == levelThreshold and chosenRarities.ability[item.rarity])) or (not levelThreshold and chosenRarities.ability[item.rarity])) then
                    local index = tonumber(string.sub(i, string.find(i, "_") + 1))
                    game:GetService("ReplicatedStorage").remotes.sellItemEvent:FireServer({["ability"] = {index}, ["helmet"] = {}, ["chest"] = {}, ["weapon"] = {}, ["ring"] = {}})
                end
            end
        end
    end
end

local function startLoop()
    if sellLoop then
        pcall(function()
            task.cancel(sellLoop)
            sellLoop = nil
        end)
    end
    sellLoop = task.spawn(function()
        while isLoopActive do
            pcall(function()
                sellItems()
                saveConfig()
            end)
            task.wait(3)
        end
    end)
end

local function saveConfig()
    local config = {
        rarities = chosenRarities,
        autoSell = isLoopActive,
        saveCollectables = saveCollectables,
        levels = {}
    }
    for itemType, input in pairs(levelInputs) do
        config.levels[itemType] = input.Text
    end
    if not isfolder("kisave") then
        makefolder("kisave")
    end
    writefile("kisave/sell_config2.txt", game:GetService("HttpService"):JSONEncode(config))
end

local function loadConfig()
    if isfolder("kisave") and isfile("kisave/sell_config2.txt") then
        local success, data = pcall(function()
            return game:GetService("HttpService"):JSONDecode(readfile("kisave/sell_config2.txt"))
        end)
        if success and data then
            if data.rarities then
                chosenRarities = data.rarities
                for itemType, rarities in pairs(chosenRarities) do
                    if typeMenus[itemType] then
                        for _, button in ipairs(typeMenus[itemType]:GetChildren()) do
                            if button:IsA("TextButton") then
                                local rarity = button.Text:lower()
                                if rarities[rarity] then
                                    button.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
                                end
                            end
                        end
                    end
                end
            end
            if data.levels then
                for itemType, level in pairs(data.levels) do
                    if levelInputs[itemType] then
                        levelInputs[itemType].Text = level
                    end
                end
            end
            if data.autoSell ~= nil then
                isLoopActive = data.autoSell
                LoopSellBtn.BackgroundColor3 = isLoopActive and Color3.fromRGB(0, 170, 255) or Color3.fromRGB(45, 45, 45)
                if isLoopActive then
                    startLoop()
                    saveConfig()
                end
            end
            if data.saveCollectables ~= nil then
                saveCollectables = data.saveCollectables
                CollectablesBtn.BackgroundColor3 = saveCollectables and Color3.fromRGB(0, 170, 255) or Color3.fromRGB(45, 45, 45)
            end
        end
    end
end

local function createRarityMenu(itemType)
    local menu = Instance.new("Frame")
    menu.Size = UDim2.new(0, 160, 0, 160)
    menu.Position = UDim2.new(1, 5, 0, 0)
    menu.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
    menu.BackgroundTransparency = 0.5
    menu.BorderSizePixel = 0
    menu.Visible = false
    menu.Parent = PrimaryFrame
    
    local MenuCorner = Instance.new("UICorner")
    MenuCorner.CornerRadius = UDim.new(0, 8)
    MenuCorner.Parent = menu
    
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Position = UDim2.new(0, 8, 0, 8)
    titleLabel.Size = UDim2.new(1, -16, 0, 20)
    titleLabel.Text = itemType:gsub("^%l", string.upper) .. " Settings"
    titleLabel.BackgroundTransparency = 1
    titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleLabel.TextSize = 14
    titleLabel.Parent = menu
    
    local levelInput = Instance.new("TextBox")
    levelInput.Position = UDim2.new(0, 8, 0, 32)
    levelInput.Size = UDim2.new(1, -16, 0, 24)
    levelInput.PlaceholderText = "Sell Below Level (ALL RARITY)"
    levelInput.Text = ""
    levelInput.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    levelInput.BackgroundTransparency = 0.5
    levelInput.TextColor3 = Color3.fromRGB(255, 255, 255)
    levelInput.PlaceholderColor3 = Color3.fromRGB(200, 200, 200)
    levelInput.TextSize = 12
    levelInput.BorderSizePixel = 0
    levelInput.Parent = menu
    
    local InputCorner = Instance.new("UICorner")
    InputCorner.CornerRadius = UDim.new(0, 6)
    InputCorner.Parent = levelInput
    
    levelInputs[itemType] = levelInput
    
    local rarities = {"legendary", "epic", "rare", "uncommon", "common"}
    for i, rarity in ipairs(rarities) do
        local toggle = Instance.new("TextButton")
        toggle.Position = UDim2.new(0, 8, 0, 64 + (i-1) * 20)
        toggle.Size = UDim2.new(1, -16, 0, 18)
        toggle.Text = rarity:gsub("^%l", string.upper)
        toggle.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
        toggle.BackgroundTransparency = 0.5
        toggle.TextColor3 = Color3.fromRGB(255, 255, 255)
        toggle.TextSize = 12
        toggle.BorderSizePixel = 0
        toggle.Parent = menu
        
        local ButtonCorner = Instance.new("UICorner")
        ButtonCorner.CornerRadius = UDim.new(0, 6)
        ButtonCorner.Parent = toggle
        
        toggle.MouseButton1Click:Connect(function()
            chosenRarities[itemType][rarity] = not chosenRarities[itemType][rarity]
            toggle.BackgroundColor3 = chosenRarities[itemType][rarity] and Color3.fromRGB(0, 170, 255) or Color3.fromRGB(45, 45, 45)
            saveConfig()
        end)
    end
    
    levelInput:GetPropertyChangedSignal("Text"):Connect(function()
        local newText = levelInput.Text:gsub("[^0-9]", "")
        if newText ~= levelInput.Text then
            levelInput.Text = newText
        end
        saveConfig()
    end)
    
    return menu
end

SingleSellBtn.Position = UDim2.new(0, 8, 1, -62)
SingleSellBtn.Size = UDim2.new(0.5, -12, 0, 24)
SingleSellBtn.Text = "Sell Once"
SingleSellBtn.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
SingleSellBtn.BackgroundTransparency = 0.5
SingleSellBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
SingleSellBtn.TextSize = 12
SingleSellBtn.BorderSizePixel = 0
SingleSellBtn.Parent = PrimaryFrame

LoopSellBtn.Position = UDim2.new(0.5, 4, 1, -62)
LoopSellBtn.Size = UDim2.new(0.5, -12, 0, 24)
LoopSellBtn.Text = "Auto Sell"
LoopSellBtn.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
LoopSellBtn.BackgroundTransparency = 0.5
LoopSellBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
LoopSellBtn.TextSize = 12
LoopSellBtn.BorderSizePixel = 0
LoopSellBtn.Parent = PrimaryFrame

CollectablesBtn.Position = UDim2.new(0, 8, 1, -32)
CollectablesBtn.Size = UDim2.new(1, -16, 0, 24)
CollectablesBtn.Text = "Save Collectables"
CollectablesBtn.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
CollectablesBtn.BackgroundTransparency = 0.5
CollectablesBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
CollectablesBtn.TextSize = 12
CollectablesBtn.BorderSizePixel = 0
CollectablesBtn.Parent = PrimaryFrame

local SellBtnCorner = Instance.new("UICorner")
SellBtnCorner.CornerRadius = UDim.new(0, 6)
SellBtnCorner.Parent = SingleSellBtn

local LoopBtnCorner = Instance.new("UICorner")
LoopBtnCorner.CornerRadius = UDim.new(0, 6)
LoopBtnCorner.Parent = LoopSellBtn

local CollectablesBtnCorner = Instance.new("UICorner")
CollectablesBtnCorner.CornerRadius = UDim.new(0, 6)
CollectablesBtnCorner.Parent = CollectablesBtn

local types = {"weapon", "ability", "chest", "helmet", "ring"}
for i, itemType in ipairs(types) do
    local toggle = Instance.new("TextButton")
    toggle.Position = UDim2.new(0, 8, 0, 35 + (i-1) * 22)
    toggle.Size = UDim2.new(1, -16, 0, 20)
    toggle.Text = itemType:gsub("^%l", string.upper)
    toggle.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    toggle.BackgroundTransparency = 0.5
    toggle.TextColor3 = Color3.fromRGB(255, 255, 255)
    toggle.TextSize = 12
    toggle.BorderSizePixel = 0
    toggle.Parent = PrimaryFrame
    
    local ButtonCorner = Instance.new("UICorner")
    ButtonCorner.CornerRadius = UDim.new(0, 6)
    ButtonCorner.Parent = toggle
    
    typeMenus[itemType] = createRarityMenu(itemType)
    
    toggle.MouseButton1Click:Connect(function()
        if selectedType == itemType then
            typeMenus[itemType].Visible = false
            selectedType = nil
        else
            if selectedType then
                typeMenus[selectedType].Visible = false
            end
            typeMenus[itemType].Visible = true
            selectedType = itemType
        end
    end)
end

PrimaryFrame:GetPropertyChangedSignal("Visible"):Connect(function()
    if not PrimaryFrame.Visible and selectedType then
        typeMenus[selectedType].Visible = false
        selectedType = nil
    end
end)

LoopSellBtn.MouseButton1Click:Connect(function()
    isLoopActive = not isLoopActive
    LoopSellBtn.BackgroundColor3 = isLoopActive and Color3.fromRGB(0, 170, 255) or Color3.fromRGB(45, 45, 45)
    
    if isLoopActive then
        startLoop()
    elseif sellLoop then
        task.cancel(sellLoop)
        sellLoop = nil
    end
    saveConfig()
end)

CollectablesBtn.MouseButton1Click:Connect(function()
    saveCollectables = not saveCollectables
    CollectablesBtn.BackgroundColor3 = saveCollectables and Color3.fromRGB(0, 170, 255) or Color3.fromRGB(45, 45, 45)
    saveConfig()
end)

SingleSellBtn.MouseButton1Click:Connect(sellItems)

task.spawn(function()
    task.wait(1)
    loadConfig()
end)

coroutine.wrap(function()
   if isfolder("kisave") and isfile("kisave/auto_dungeon_state.txt") and readfile("kisave/auto_dungeon_state.txt") == "true" then
       local firstSymbols = {"5"}
               
       for _, firstSymbol in ipairs(firstSymbols) do
           local args1 = {
               [1] = {
                   [1] = {
                       [1] = "\001"
                   },
                   [2] = firstSymbol
               }
           }
           game:GetService("ReplicatedStorage").dataRemoteEvent:FireServer(unpack(args1))
           
           wait(1.5)
       end
       
       local symbols = {"M", "\152"}
       
       for _, symbol in ipairs(symbols) do
           local args2 = {
               [1] = {
                   [1] = {
                       [1] = "\001",
                       [2] = {
                           ["characterIndex"] = selectedCharacter,
                           ["\003"] = "select"
                       }
                   },
                   [2] = symbol
               }
           }
           game:GetService("ReplicatedStorage").dataRemoteEvent:FireServer(unpack(args2))
           
           wait(1.5)
       end
   end
end)()

    local function waitForStartButton()
        local HUD = player:WaitForChild("PlayerGui"):WaitForChild("HUD")
        local MainFrame = HUD:WaitForChild("Main")
        local MobileFrame = HUD:WaitForChild("Mobile")
        local MainStartButton = MainFrame:WaitForChild("StartButton")
        local MobileStartButton = MobileFrame:WaitForChild("StartButton")
        return MainStartButton.Visible or MobileStartButton.Visible
    end

    waitForStartButton()
    
    local symbols = {"9"}

for _, symbol in ipairs(symbols) do
   local args = {
       [1] = {
           [1] = {
               [1] = "\001",
               [2] = {
                   ["\003"] = "redeemReward"
               }
           },
           [2] = symbol
       }
   }
   
   game:GetService("ReplicatedStorage").dataRemoteEvent:FireServer(unpack(args))
   wait(0.1)
end
    
    local gui = Instance.new("ScreenGui")
    gui.ResetOnSpawn = false
    gui.DisplayOrder = 999999
    gui.Parent = player:WaitForChild("PlayerGui")

    local function createFrame()
        local frame = Instance.new("Frame")
        frame.Size = UDim2.new(0, 220, 0, 280)
        frame.Position = UDim2.new(0.5, -120, 0.5, -140)
        frame.BackgroundTransparency = 1
        frame.BorderSizePixel = 0
        frame.Parent = gui

        local backgroundImage = Instance.new("ImageLabel")
        backgroundImage.Size = UDim2.new(1, 0, 1, 0)
        backgroundImage.BackgroundTransparency = 1
        backgroundImage.Image = "rbxassetid://14662856377"
        backgroundImage.ImageTransparency = 0.4
        backgroundImage.Parent = frame

        local rainbow = Instance.new("UIStroke")
        rainbow.Thickness = 2
        rainbow.Parent = frame

        RunService.RenderStepped:Connect(function()
            local t = tick() * 0.5
            local hue = (math.sin(t) + 1) / 2
            rainbow.Color = Color3.fromHSV(hue, 1, 1)
        end)

        local shadow = Instance.new("ImageLabel")
        shadow.Size = UDim2.new(1, 30, 1, 30)
        shadow.Position = UDim2.new(0.5, 0, 0.5, 0)
        shadow.AnchorPoint = Vector2.new(0.5, 0.5)
        shadow.BackgroundTransparency = 1
        shadow.Image = "rbxassetid://5554236805"
        shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
        shadow.ImageTransparency = 0.4
        shadow.ScaleType = Enum.ScaleType.Slice
        shadow.SliceCenter = Rect.new(23, 23, 277, 277)
        shadow.Parent = frame
        
        local discordButton = createDiscordButton(frame, UDim2.new(1, -40, 0, 0))
        
        return frame
    end

    local function createLabel(parent, text, size, position, textSize, font, color)
        local label = Instance.new("TextLabel")
        label.Size = size
        label.Position = position
        label.BackgroundTransparency = 1
        label.Font = font
        label.Text = text
        label.TextColor3 = color
        label.TextSize = textSize
        label.Parent = parent
        return label
    end

    local function createButton(parent, text, position)
        local button = Instance.new("TextButton")
        button.Size = UDim2.new(0.3, 0, 0, 25)
        button.Position = position
        button.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
        button.BackgroundTransparency = 0.5
        button.Font = Enum.Font.GothamSemibold
        button.TextColor3 = Color3.fromRGB(255, 255, 255)
        button.TextSize = 10
        button.Text = text
        button.AutoButtonColor = false
        button.Parent = parent
        Instance.new("UICorner", button).CornerRadius = UDim.new(0, 8)
        return button
    end

    local isDraggingGUI = false
    local activeSlider = nil

local function saveTeleportDelay(value)
    local saveFolder = "kisave"
    if not isfolder(saveFolder) then makefolder(saveFolder) end
    writefile(saveFolder .. "/teleport_delay.txt", tostring(value))
end

local function loadTeleportDelay()
    local saveFolder, fileName = "kisave", "kisave/teleport_delay.txt"
    if isfolder(saveFolder) and isfile(fileName) then
        return tonumber(readfile(fileName)) or 2
    end
    return 2
end

local function saveDistanceDelay(value)
    local saveFolder = "kisave"
    if not isfolder(saveFolder) then makefolder(saveFolder) end
    writefile(saveFolder .. "/distance_delay.txt", tostring(value))
end

local function loadDistanceDelay()
    local saveFolder, fileName = "kisave", "kisave/distance_delay.txt"
    if isfolder(saveFolder) and isfile(fileName) then
        return tonumber(readfile(fileName)) or 2
    end
    return 6
end

local function saveSelectedStat(statType)
    local saveFolder = "kisave"
    if not isfolder(saveFolder) then makefolder(saveFolder) end
    writefile(saveFolder .. "/selected_stat.txt", statType)
end

local function loadSelectedStat()
    local saveFolder, fileName = "kisave", "kisave/selected_stat.txt"
    if isfolder(saveFolder) and isfile(fileName) then
        return readfile(fileName)
    end
    return nil
end

    local function createSlider(parent, text, min, max, default, yPos)
    local sliderFrame = Instance.new("Frame")
    sliderFrame.Size = UDim2.new(0.9, 0, 0, 40)
    sliderFrame.Position = UDim2.new(0.05, 0, 0, yPos)
    sliderFrame.BackgroundTransparency = 1
    sliderFrame.Parent = parent

    createLabel(sliderFrame, text, UDim2.new(1, 0, 0, 20), UDim2.new(0, 0, 0, 0), 11, Enum.Font.Gotham, Color3.fromRGB(200, 200, 200))

    local sliderBG = Instance.new("Frame")
    sliderBG.Size = UDim2.new(1, 0, 0, 5)
    sliderBG.Position = UDim2.new(0, 0, 1, -8)
    sliderBG.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    sliderBG.BorderSizePixel = 0
    sliderBG.Parent = sliderFrame
    Instance.new("UICorner", sliderBG).CornerRadius = UDim.new(0, 2)

    local sliderFill = Instance.new("Frame")
    sliderFill.Size = UDim2.new((default - min) / (max - min), 0, 1, 0)
    sliderFill.BackgroundColor3 = Color3.fromRGB(0, 120, 215)
    sliderFill.BorderSizePixel = 0
    sliderFill.Parent = sliderBG
    Instance.new("UICorner", sliderFill).CornerRadius = UDim.new(0, 2)

    local sliderButton = Instance.new("TextButton")
    sliderButton.Size = UDim2.new(0, 12, 0, 12)
    sliderButton.Position = UDim2.new((default - min) / (max - min), -6, 0.5, -6)
    sliderButton.AnchorPoint = Vector2.new(0, 0.5)
    sliderButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    sliderButton.Text = ""
    sliderButton.Parent = sliderBG
    Instance.new("UICorner", sliderButton).CornerRadius = UDim.new(0, 6)

    local valueLabel = createLabel(sliderFrame, tostring(default), UDim2.new(0, 30, 0, 20), UDim2.new(1, -30, 0, 0), 11, Enum.Font.Gotham, Color3.fromRGB(200, 200, 200))
    valueLabel.TextXAlignment = Enum.TextXAlignment.Right

    local value = default
    
    local function updateSlider(input)
        if isDraggingGUI then return end
        local pos = math.clamp((input.Position.X - sliderBG.AbsolutePosition.X) / sliderBG.AbsoluteSize.X, 0, 1)
        value = math.floor((min + (max - min) * pos) * 100) / 100
        sliderFill.Size = UDim2.new(pos, 0, 1, 0)
        sliderButton.Position = UDim2.new(pos, -6, 0.5, -6)
        valueLabel.Text = tostring(value)
        return value
    end

    local function onInputBegan(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            if not activeSlider and not isDraggingGUI then
                activeSlider = sliderButton
                updateSlider(input)
            end
        end
    end

    local function onInputEnded(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            if activeSlider == sliderButton then
                activeSlider = nil
            end
        end
    end

    local function onInputChanged(input)
        if activeSlider == sliderButton and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            updateSlider(input)
        end
    end

    sliderButton.InputBegan:Connect(onInputBegan)
    sliderBG.InputBegan:Connect(onInputBegan)
    UserInputService.InputEnded:Connect(onInputEnded)
    UserInputService.InputChanged:Connect(onInputChanged)

    local function getValue()
        return value
    end

    local function setValue(newValue)
        value = math.floor(math.clamp(newValue, min, max) * 100) / 100
        local pos = (value - min) / (max - min)
        sliderFill.Size = UDim2.new(pos, 0, 1, 0)
        sliderButton.Position = UDim2.new(pos, -6, 0.5, -6)
        valueLabel.Text = tostring(value)
    end

    return getValue, setValue
end
    
    local function createTextBox(parent, placeholder, position)
        local textBox = Instance.new("TextBox")
        textBox.Size = UDim2.new(0.9, 0, 0, 30)
        textBox.Position = position
        textBox.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
        textBox.BackgroundTransparency = 0.5
        textBox.Font = Enum.Font.GothamSemibold
        textBox.TextColor3 = Color3.fromRGB(255, 255, 255)
        textBox.TextSize = 12
        textBox.PlaceholderText = placeholder
        textBox.Text = ""
        textBox.Parent = parent
        Instance.new("UICorner", textBox).CornerRadius = UDim.new(0, 8)
        return textBox
    end

    local frame = createFrame()
createLabel(frame, "Kinayo Scripts", UDim2.new(1, 0, 0, 25), UDim2.new(0, 0, 0, 8), 16, Enum.Font.GothamBold, Color3.fromRGB(255, 255, 255))
createLabel(frame, "Dungeon Quest", UDim2.new(1, 0, 0, 18), UDim2.new(0, 0, 0, 30), 12, Enum.Font.Gotham, Color3.fromRGB(200, 200, 200))

local getDistance, setDistance = createSlider(frame, "Distance", 0, 20, loadDistanceDelay(), 60)
local getTeleportSpeed, setTeleportSpeed = createSlider(frame, "Teleport Delay", 0, 5, loadTeleportDelay(), 110)

local resetButton = createResetButton(frame, UDim2.new(1, -40, 0, 25))

resetButton.MouseButton1Click:Connect(function()
    setDistance(6)
    setTeleportSpeed(2)
    saveDistanceDelay(6)
    saveTeleportDelay(2)
    showNotification("Reset", "Sliders have been reset to default values", 3)
end)

local function saveSliderValues()
    while true do
        saveTeleportDelay(getTeleportSpeed())
        saveDistanceDelay(getDistance())
        task.wait(1)
    end
end

coroutine.wrap(saveSliderValues)()

local teleportButton = createButton(frame, "Auto Join", UDim2.new(0.35, 0, 0, 220))  
teleportButton.MouseButton1Click:Connect(function() 
   if MainFrame.Visible then
       MainFrame.Visible = false
   else
       MainFrame.Visible = true
       PrimaryFrame.Visible = false
   end
end)  

local teleportButton = createButton(frame, "Autosell", UDim2.new(0.35, 0, 0, 190))  
teleportButton.MouseButton1Click:Connect(function() 
   if PrimaryFrame.Visible then
       PrimaryFrame.Visible = false
   else
       PrimaryFrame.Visible = true
       MainFrame.Visible = false
   end
end)

local autofarmButton = createButton(frame, "Autofarm", UDim2.new(0.05, 0, 0, 160))
autofarmButton.Size = UDim2.new(0.3, 0, 0, 25)

local greggfarmButton = createButton(frame, "Gregg Farm", UDim2.new(0.35, 0, 0, 250))
greggfarmButton.Size = UDim2.new(0.3, 0, 0, 25)

local wavefarmButton = createButton(frame, "Wavefarm", UDim2.new(0.05, 0, 0, 190))
wavefarmButton.Size = UDim2.new(0.3, 0, 0, 25)

local disableRenderButton = createButton(frame, "Disable Render", UDim2.new(0.05, 0, 0, 220))
disableRenderButton.Size = UDim2.new(0.3, 0, 0, 25)

local bonusBossButton = createButton(frame, "Bonus Boss: OFF", UDim2.new(0.65, 0, 0, 250))
bonusBossButton.Size = UDim2.new(0.3, 0, 0, 25)

local weaponSelectButton = createButton(frame, "Killaura Type", UDim2.new(0.65, 0, 0, 160))
weaponSelectButton.Size = UDim2.new(0.3, 0, 0, 25)

local dropdownFrame = Instance.new("Frame")
dropdownFrame.Size = UDim2.new(1, 0, 0, 150)
dropdownFrame.Position = UDim2.new(1.02, 0, 0, 0)
dropdownFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
dropdownFrame.BorderSizePixel = 1
dropdownFrame.BorderColor3 = Color3.fromRGB(60, 60, 60)
dropdownFrame.Visible = false
dropdownFrame.Parent = weaponSelectButton

local weaponTypes = {"LargeWeapon", "SmallWeapon", "DualWeapons", "SwordAndShield", "Staff", "Fists"}

local function saveWeaponType(weaponType)
   local saveFolder = "kisave"
   if not isfolder(saveFolder) then makefolder(saveFolder) end
   writefile(saveFolder .. "/weapon_type.txt", weaponType)
end

local function loadWeaponType()
   local saveFolder, fileName = "kisave", "kisave/weapon_type.txt"
   if isfolder(saveFolder) and isfile(fileName) then
       return readfile(fileName)
   end
   return "LargeWeapon"
end

for i, weaponType in ipairs(weaponTypes) do
   local button = Instance.new("TextButton")
   button.Size = UDim2.new(1, 0, 0, 25)
   button.Position = UDim2.new(0, 0, 0, (i-1) * 25)
   button.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
   button.BorderSizePixel = 0
   button.Text = weaponType
   button.TextColor3 = Color3.fromRGB(255, 255, 255)
   button.Font = Enum.Font.SourceSans
   button.TextSize = 14
   button.Parent = dropdownFrame
   
   button.MouseEnter:Connect(function()
       button.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
   end)
   
   button.MouseLeave:Connect(function()
       button.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
   end)
   
   button.MouseButton1Click:Connect(function()
       getgenv().WeaponType = weaponType
       weaponSelectButton.Text = "Weapon: " .. weaponType
       dropdownFrame.Visible = false
       saveWeaponType(weaponType)
   end)
end

weaponSelectButton.MouseButton1Click:Connect(function()
   dropdownFrame.Visible = not dropdownFrame.Visible
end)

local savedWeaponType = loadWeaponType()
weaponSelectButton.Text = "Weapon: " .. savedWeaponType

local useSkillsSwitch = Instance.new("TextButton")
useSkillsSwitch.Size = UDim2.new(0.3, 0, 0, 25)
useSkillsSwitch.Position = UDim2.new(0.65, 0, 0, 190)
useSkillsSwitch.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
useSkillsSwitch.BackgroundTransparency = 0.5
useSkillsSwitch.Font = Enum.Font.GothamSemibold
useSkillsSwitch.TextColor3 = Color3.fromRGB(255, 255, 255)
useSkillsSwitch.TextSize = 10
useSkillsSwitch.Text = "Use Skills: OFF"
useSkillsSwitch.Parent = frame
Instance.new("UICorner", useSkillsSwitch).CornerRadius = UDim.new(0, 8)

local holdSkillsSwitch = Instance.new("TextButton")
holdSkillsSwitch.Size = UDim2.new(0.3, 0, 0, 25)
holdSkillsSwitch.Position = UDim2.new(0.05, 0, 0, 250)
holdSkillsSwitch.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
holdSkillsSwitch.BackgroundTransparency = 0.5
holdSkillsSwitch.Font = Enum.Font.GothamSemibold
holdSkillsSwitch.TextColor3 = Color3.fromRGB(255, 255, 255)
holdSkillsSwitch.TextSize = 10
holdSkillsSwitch.Text = "Hold Skills: OFF"
holdSkillsSwitch.Parent = frame
Instance.new("UICorner", holdSkillsSwitch).CornerRadius = UDim.new(0, 8)

local isAutofarming, isWavefarming, currentTarget = false, false, false, nil, nil
local originalGravity = workspace.Gravity
local isRenderDisabled = false
local isGreggFarmEnabled = false

local function saveRenderState()
        local saveFolder = "kisave"
        if not isfolder(saveFolder) then makefolder(saveFolder) end
        writefile(saveFolder .. "/render_state.txt", tostring(isRenderDisabled))
    end

    local function loadRenderState()
        local saveFolder, fileName = "kisave", "kisave/render_state.txt"
        return isfolder(saveFolder) and isfile(fileName) and readfile(fileName) == "true"
    end

    local function getNextEnemy(enemyFolder)
    local nearestEnemy, nearestDistance = nil, math.huge
    local player = game.Players.LocalPlayer
    local character = player.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
    
    if not humanoidRootPart then return nil end
    
    local playerPosition = humanoidRootPart.Position

    local allowedFolders = {"dungeon", "enemyFolder", "enemies"}

    local function isInAllowedFolder(enemy)
        local parent = enemy.Parent
        while parent and parent ~= workspace do
            if table.find(allowedFolders, parent.Name) then
                return true
            elseif parent.Name == "enemyPool" then
                return false
            end
            parent = parent.Parent
        end
        return false
    end

    for _, enemy in ipairs(enemyFolder:GetChildren()) do
        if enemy:IsA("Model") and 
           enemy:FindFirstChild("HumanoidRootPart") and 
           enemy:FindFirstChild("Humanoid") and 
           enemy.Humanoid.Health > 0 and
           isInAllowedFolder(enemy) then
            
            local distance = (enemy.HumanoidRootPart.Position - playerPosition).Magnitude
            if distance < nearestDistance then
                nearestEnemy, nearestDistance = enemy, distance
            end
        end
    end

    return nearestEnemy
end
    
    local function teleportTo(target)
        local character = player.Character
        if not character then return end
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if not humanoidRootPart then return end

        local targetPart
        if target:IsA("Model") then
            targetPart = target.PrimaryPart or target:FindFirstChildWhichIsA("BasePart")
        elseif target:IsA("BasePart") then
            targetPart = target
        end

        if not targetPart then return end

        humanoidRootPart.CFrame = targetPart.CFrame
    end

local function resetKeyPresses()
    local VirtualInputManager = game:GetService("VirtualInputManager")
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Q, false, game)
end

local function createAndAttachPart(hand)
    local attachmentPart = Instance.new("Part")
    attachmentPart.Name = "AttachmentPart"
    attachmentPart.Size = Vector3.new(1, 1, 1)
    attachmentPart.Transparency = 1
    attachmentPart.CanCollide = false
    attachmentPart.Anchored = false

    local weld = Instance.new("WeldConstraint")
    weld.Part0 = hand.HumanoidRootPart
    weld.Part1 = attachmentPart
    weld.Parent = attachmentPart

    attachmentPart.CFrame = hand.HumanoidRootPart.CFrame * CFrame.new(0, 30, 0)
    attachmentPart.Parent = hand

    return attachmentPart
end

local function createAttachmentPartsForHands()
    local handNames = {"Red Hand", "Blue Hand", "Purple Hand", "Green Hand"}
    for _, handName in ipairs(handNames) do
        local hand = workspace:FindFirstChild(handName)
        if hand and hand:FindFirstChild("HumanoidRootPart") and not hand:FindFirstChild("AttachmentPart") then
            createAndAttachPart(hand)
        end
    end
end

local function changeDisplays()
    local player = game:GetService("Players").LocalPlayer
    
    if player.PlayerGui.HUD.Mobile then
        if player.PlayerGui.HUD.Mobile.PlayerStatus then
            local mobilePlayerStatus = player.PlayerGui.HUD.Mobile.PlayerStatus:FindFirstChild("PlayerStatus")
            if mobilePlayerStatus then
                local playerName = mobilePlayerStatus:FindFirstChild("PlayerName")
                if playerName then
                    playerName.Text = discordLink
                end
                
                local level = mobilePlayerStatus:FindFirstChild("Level")
                if level then
                    local textLabel = level:FindFirstChild("TextLabel")
                    if textLabel then
                        textLabel.Text = "K"
                    end
                end
                
                local portrait = mobilePlayerStatus:FindFirstChild("Portrait")
                if portrait then
                    local frame = portrait:FindFirstChild("Frame")
                    if frame then
                        local imageLabel = frame:FindFirstChild("ImageLabel")
                        if imageLabel then
                            imageLabel.Image = "rbxassetid://14662856377"
                        end
                    end
                end
            end
        end
    end
    
    if player.PlayerGui.HUD.Main then
        if player.PlayerGui.HUD.Main.PlayerStatus then
            local mainPlayerStatus = player.PlayerGui.HUD.Main.PlayerStatus:FindFirstChild("PlayerStatus")
            if mainPlayerStatus then
                local playerName = mainPlayerStatus:FindFirstChild("PlayerName")
                if playerName then
                    playerName.Text = discordLink
                end
                
                local level = mainPlayerStatus:FindFirstChild("Level")
                if level then
                    local textLabel = level:FindFirstChild("TextLabel")
                    if textLabel then
                        textLabel.Text = "K"
                    end
                end
                
                local portrait = mainPlayerStatus:FindFirstChild("Portrait")
                if portrait then
                    local frame = portrait:FindFirstChild("Frame")
                    if frame then
                        local imageLabel = frame:FindFirstChild("ImageLabel")
                        if imageLabel then
                            imageLabel.Image = "rbxassetid://14662856377"
                        end
                    end
                end
            end
        end
    end
    
    local playerModel = workspace:FindFirstChild(player.Name)
    if playerModel then
        local head = playerModel:FindFirstChild("Head")
        if head then
            local nameplate = head:FindFirstChild("playerNameplate")
            if nameplate then
                nameplate:Destroy()
            end
        end
    end
end

spawn(function()
    while wait(0.1) do
        pcall(changeDisplays)
    end
end)

local autofarmv2Button = Instance.new("TextButton")
autofarmv2Button.Size = UDim2.new(0.3, 0, 0, 25)
autofarmv2Button.Position = UDim2.new(0.35, 0, 0, 160)
autofarmv2Button.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
autofarmv2Button.BackgroundTransparency = 0.5
autofarmv2Button.Font = Enum.Font.GothamSemibold
autofarmv2Button.TextColor3 = Color3.fromRGB(255, 255, 255)
autofarmv2Button.TextSize = 10
autofarmv2Button.Text = "Autofarm v2"
autofarmv2Button.Parent = frame
Instance.new("UICorner", autofarmv2Button).CornerRadius = UDim.new(0, 8)

local isAutofarmv2 = false
local currentTarget = nil

local function saveAutofarmv2State()
    local saveFolder = "kisave"
    if not isfolder(saveFolder) then makefolder(saveFolder) end
    writefile(saveFolder .. "/autofarmv2_state.txt", tostring(isAutofarmv2))
end

local function loadAutofarmv2State()
    local saveFolder, fileName = "kisave", "kisave/autofarmv2_state.txt"
    if isfolder(saveFolder) and isfile(fileName) then
        local state = readfile(fileName)
        return state == "true"
    end
    return false
end

local function autofarmv2()
    local TweenService = game:GetService("TweenService")
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    
    local player = Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    
    local function disableCollisions(obj)
        for _, part in pairs(obj:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end
    
    local function stabilizeCharacter(humanoidRootPart)
        humanoidRootPart.Velocity = Vector3.new(0, 0, 0)
        humanoidRootPart.RotVelocity = Vector3.new(0, 0, 0)
        humanoidRootPart.CFrame = CFrame.new(humanoidRootPart.Position, humanoidRootPart.Position + Vector3.new(0, 0, -1))
    end
    
    local function findNearestEnemy()
        local priorityTargets = {}
        local nearestEnemy = nil
        local nearestDistance = math.huge
        
        local dungeonFolder = workspace:FindFirstChild("dungeon")
        if dungeonFolder then
            for _, room in pairs(dungeonFolder:GetChildren()) do
                local enemyFolder = room:FindFirstChild("enemyFolder")
                if enemyFolder then
                    for _, enemy in pairs(enemyFolder:GetChildren()) do
                        if enemy:IsA("Model") and enemy:FindFirstChild("HumanoidRootPart") then
                            local enemyHumanoid = enemy:FindFirstChild("Humanoid")
                            if enemyHumanoid and enemyHumanoid.Health > 0 then
                                if enemy.Name == "The Voidborn" or enemy.Name == "Voidskitter" then
                                    table.insert(priorityTargets, enemy)
                                else
                                    local distance = (humanoidRootPart.Position - enemy.HumanoidRootPart.Position).Magnitude
                                    if distance < nearestDistance then
                                        nearestDistance = distance
                                        nearestEnemy = enemy
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        
        if #priorityTargets > 0 then
            return priorityTargets[1]
        else
            return nearestEnemy
        end
    end
    
    local function teleportToPosition(position)
        if humanoidRootPart then
            humanoidRootPart.CFrame = CFrame.new(position)
        end
    end
    
    disableCollisions(character)
    
    spawn(function()
        while isAutofarmv2 do
            wait(0.1)
            if character and character:FindFirstChild("HumanoidRootPart") then
                stabilizeCharacter(character.HumanoidRootPart)
            end
        end
    end)
    
    spawn(function()
        player.CharacterAdded:Connect(function()
            if isAutofarmv2 then
                wait(0.5)
                autofarmv2()
            end
        end)
    end)
    
    local currentTween = nil
    
    spawn(function()
        while isAutofarmv2 do
            if not character or not character.Parent then
                return
            end
            
            local nearestEnemy = findNearestEnemy()
            
            if currentTarget then
                local targetHumanoid = currentTarget:FindFirstChild("Humanoid")
                if not currentTarget.Parent or not targetHumanoid or targetHumanoid.Health <= 0 then
                    if currentTween then
                        currentTween:Cancel()
                    end
                    currentTarget = nil
                end
            end
            
            if nearestEnemy and nearestEnemy ~= currentTarget then
                if currentTween then
                    currentTween:Cancel()
                end
                currentTarget = nearestEnemy
            end
            
            if currentTarget then
                local targetCFrame
                
                if currentTarget.Name == "The Voidborn" then
                    targetCFrame = CFrame.new(Vector3.new(2392, -623, 77))
                elseif currentTarget.Name == "Corrupted Growth" then
                    targetCFrame = currentTarget.HumanoidRootPart.CFrame * CFrame.new(0, -30, 0)
                elseif currentTarget.Name == "Eldritch Reaver" then
                    targetCFrame = currentTarget.HumanoidRootPart.CFrame * CFrame.new(0, -20, 0)
                elseif currentTarget.Name == "Voidshade" then
                    targetCFrame = currentTarget.HumanoidRootPart.CFrame * CFrame.new(0, 13, 10)
                elseif currentTarget.Name == "Adelys" then
                    targetCFrame = CFrame.new(Vector3.new(1586, -487, 101))
                elseif currentTarget.Name == "Exalted Queensguard" then
                    targetCFrame = currentTarget.HumanoidRootPart.CFrame
                elseif currentTarget.Name == "Elite Queensguard" then
                    targetCFrame = currentTarget.HumanoidRootPart.CFrame
                else
                    targetCFrame = currentTarget.HumanoidRootPart.CFrame * CFrame.new(0, 13, 0)
                end
                
                local distance = (humanoidRootPart.Position - targetCFrame.Position).Magnitude
                
                if distance > 120 then
                    teleportToPosition(targetCFrame.Position)
                else
                    local tweenTime = distance / 30
                    
                    local tweenInfo = TweenInfo.new(
                        tweenTime,
                        Enum.EasingStyle.Linear,
                        Enum.EasingDirection.InOut,
                        0,
                        false,
                        0
                    )
                    
                    currentTween = TweenService:Create(
                        humanoidRootPart,
                        tweenInfo,
                        {CFrame = targetCFrame}
                    )
                    
                    currentTween:Play()
                    currentTween.Completed:Wait()
                end
            end
            
            wait(0.1)
        end
    end)
end

autofarmv2Button.MouseButton1Click:Connect(function()
    isAutofarmv2 = not isAutofarmv2
    autofarmv2Button.BackgroundColor3 = isAutofarmv2 and Color3.fromRGB(0, 120, 215) or Color3.fromRGB(45, 45, 45)
    saveAutofarmv2State()
    
    if isAutofarmv2 then
        task.spawn(function()
            autofarmv2()
        end)
        
        coroutine.wrap(function()
            task.wait(2)
            frame.Visible = false
            isGuiVisible = false
        end)()
    end
end)

isAutofarmv2 = loadAutofarmv2State()
autofarmv2Button.BackgroundColor3 = isAutofarmv2 and Color3.fromRGB(0, 120, 215) or Color3.fromRGB(45, 45, 45)

if isAutofarmv2 then
    task.spawn(function()
        autofarmv2()
    end)
    
    coroutine.wrap(function()
        task.wait(2)
        frame.Visible = false
        isGuiVisible = false
    end)()
end

local function anchorPlayer(character)
    if not character then return end
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart then
        humanoidRootPart.Anchored = true
    end
    
    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") and part ~= humanoidRootPart then
            part.Anchored = true
        end
    end
end

local function unanchorPlayer(character)
    if not character then return end
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart then
        humanoidRootPart.Anchored = false
    end
    
    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") and part ~= humanoidRootPart then
            part.Anchored = false
        end
    end
end

local function farm(getEnemyFolders)
    local ANIMATION_TABLE = {
        ["LargeWeapon"] = {
            ["Idle"] = 87776815396170,
            ["Run"] = 132363319545954,
            ["Attacks"] = { "rbxassetid://115725251079211", "rbxassetid://91994339000643", "rbxassetid://74447788907886" }
        },
        ["SmallWeapon"] = {
            ["Idle"] = 76270721636286,
            ["Run"] = 134108776094003,
            ["Attacks"] = { "rbxassetid://115725251079211", "rbxassetid://91994339000643", "rbxassetid://74447788907886" }
        },
        ["DualWeapons"] = {
            ["Idle"] = 133279515020830,
            ["Run"] = 108019923425961,
            ["Attacks"] = { "rbxassetid://13740049334", "rbxassetid://13740049269", "rbxassetid://13740049305" },
            ["TempIgnoreAttackKeyFrame"] = true
        },
        ["SwordAndShield"] = {
            ["Idle"] = 134863424878930,
            ["Run"] = 109165703984291,
            ["Attacks"] = { "rbxassetid://13740049395", "rbxassetid://13740049453" },
            ["TempIgnoreAttackKeyFrame"] = true
        },
        ["Staff"] = {
            ["Idle"] = 87776815396170,
            ["Run"] = 132363319545954,
            ["Attacks"] = { "rbxassetid://110836226084253", "rbxassetid://115030158661285", "rbxassetid://118125784297769" }
        },
        ["Fists"] = {
            ["Idle"] = 14201837624,
            ["Run"] = 14201837715,
            ["Attacks"] = { "rbxassetid://13740049031", "rbxassetid://13740048897" },
            ["TempIgnoreAttackKeyFrame"] = true
        }
    }
    
    getgenv().WeaponType = savedWeaponType
    local AnimationObject = nil
    local Animation = nil
    local CurrentIndex = 0
    local lastPositionCheck = tick()
    local lastPlayerPosition = nil
    
    local function GetKillAuraArgs(index)
        return {[1] = {{ ["animationIndex"] = index, ["sentAt"] = tick() + (tick() % 1) }, "\175"}}
    end
    
    local function UpdateAnimationByIndex(index)
        AnimationObject.AnimationId = ANIMATION_TABLE[getgenv().WeaponType].Attacks[index]
    end
    
    local function CreateAnimation()
        AnimationObject = Instance.new("Animation")
        AnimationObject.Parent = player.Character
        UpdateAnimationByIndex(1)
        return AnimationObject
    end
    
    local function InitializeKillAura()
        if Animation then
            Animation:Destroy()
            Animation = nil
        end
        if AnimationObject then
            AnimationObject:Destroy()
            AnimationObject = nil
        end
        
        CreateAnimation()
        local Humanoid = player.Character:WaitForChild("Humanoid")
        Animation = Humanoid:LoadAnimation(AnimationObject)
    end
    
    createAttachmentPartsForHands()
    local lastEnemyPosition = Vector3.new(0, 0, 0)
    local farDistanceThreshold = 40
    
    local function stabilizeCharacter(humanoidRootPart)
        humanoidRootPart.Velocity = Vector3.new(0, 0, 0)
        humanoidRootPart.RotVelocity = Vector3.new(0, 0, 0)
        humanoidRootPart.CFrame = CFrame.new(humanoidRootPart.Position, humanoidRootPart.Position + Vector3.new(0, 0, -1))
    end
    
    local function getPriorityTarget(enemyFolders)
        local priorityOrder = {"Exalted Queensguard", "Eldritch Prophet", "Red Hand", "Blue Hand", "Purple Hand", "Green Hand"}
        
        for _, targetName in ipairs(priorityOrder) do
            for _, folder in ipairs(enemyFolders) do
                for _, enemy in ipairs(folder:GetChildren()) do
                    if enemy.Name == targetName and enemy:FindFirstChild("Humanoid") and enemy.Humanoid.Health > 0 then
                        return enemy
                    end
                end
            end
        end
        return nil
    end
    
    local function handleCharacterDeath()
        local character = player.Character
        if not character then return end
        
        local humanoid = character:WaitForChild("Humanoid")
        humanoid.Died:Connect(function()
            if Animation then
                Animation:Destroy()
                Animation = nil
            end
            if AnimationObject then
                AnimationObject:Destroy()
                AnimationObject = nil
            end
            
            player.CharacterAdded:Wait()
            task.wait(0.5)
            InitializeKillAura()
        end)
    end
    
    task.spawn(function()
        while isAutofarming or isWavefarming do
            if not Animation or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                task.wait(0.5)
                if (isAutofarming or isWavefarming) and player.Character then
                    InitializeKillAura()
                end
                continue
            end
            
            CurrentIndex = (CurrentIndex % #ANIMATION_TABLE[getgenv().WeaponType].Attacks) + 1
            game:GetService("ReplicatedStorage").dataRemoteEvent:FireServer(unpack(GetKillAuraArgs(CurrentIndex)))
            UpdateAnimationByIndex(CurrentIndex)
            
            if Animation then
                Animation:Play()
                Animation:Stop()
            end
            
            task.wait()
        end
    end)
    
    handleCharacterDeath()
    InitializeKillAura()
    
    while isAutofarming or isWavefarming do
        local character = player.Character
        if not character then task.wait(1) continue end
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        local humanoid = character:FindFirstChild("Humanoid")
        if not humanoidRootPart or not humanoid or humanoid.Health <= 0 then task.wait(1) continue end
        
        humanoid.PlatformStand = true
        workspace.Gravity = 0
        
        local currentPosition = humanoidRootPart.Position
        if lastPlayerPosition then
            if (currentPosition - lastPlayerPosition).Magnitude < 5 then
                if tick() - lastPositionCheck >= 30 then
                    humanoid.Health = 0
                    lastPositionCheck = tick()
                    lastPlayerPosition = nil
                end
            else
                lastPositionCheck = tick()
                lastPlayerPosition = currentPosition
            end
        else
            lastPositionCheck = tick()
            lastPlayerPosition = currentPosition
        end
        
        if not currentTarget then
            stabilizeCharacter(humanoidRootPart)
            task.wait(0.1)
        end
        
        local orbBlue = workspace:FindFirstChild("OrbBlue")
        if orbBlue then
            local sphere = orbBlue:FindFirstChild("Sphere")
            if sphere then
                stabilizeCharacter(humanoidRootPart)
                unanchorPlayer(character)
                task.wait(0.1)
                humanoidRootPart.CFrame = sphere.CFrame
                task.wait(0.1)
                anchorPlayer(character)
                task.wait(1)
                
                local teslaCeil = workspace:FindFirstChild("Tesla Coil")
                if teslaCeil then
                    local cylinder = teslaCeil:FindFirstChild("Cylinder")
                    if cylinder then
                        unanchorPlayer(character)
                        task.wait(0.1)
                        humanoidRootPart.CFrame = cylinder.CFrame
                        task.wait(0.1)
                        anchorPlayer(character)
                        task.wait(1)
                    end
                end
                continue
            end
        end
        
        local playerPickupCannonballRing = workspace:FindFirstChild("playerPickupCannonballRing")
        if playerPickupCannonballRing and playerPickupCannonballRing.Transparency == 0 then
            stabilizeCharacter(humanoidRootPart)
            unanchorPlayer(character)
            task.wait(0.1)
            humanoidRootPart.CFrame = playerPickupCannonballRing.CFrame
            task.wait(0.1)
            anchorPlayer(character)
            task.wait(4)
            
            local playerFireCannon = workspace:FindFirstChild("playerFireCannon")
            if playerFireCannon then
                local ring = playerFireCannon:FindFirstChild("ring")
                if ring then
                    unanchorPlayer(character)
                    task.wait(0.1)
                    humanoidRootPart.CFrame = ring.CFrame
                    task.wait(0.1)
                    anchorPlayer(character)
                    task.wait(4)
                end
            end
            continue
        end
        
        local coin = workspace:FindFirstChild("Coin")
        if coin then
            local randomPart = coin:FindFirstChildWhichIsA("BasePart")
            if randomPart then
                stabilizeCharacter(humanoidRootPart)
                local tweenInfo = TweenInfo.new(2, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
                local tween = TweenService:Create(humanoidRootPart, tweenInfo, {CFrame = randomPart.CFrame})
                tween:Play()
                tween.Completed:Wait()
                continue
            end
        end
        
        local azrallikHeart = workspace:FindFirstChild("Azrallik's Heart")
        local odinReincarnation = workspace:FindFirstChild("Odin Reincarnation")
        local tether
        local dungeon = workspace:FindFirstChild("dungeon")
        if dungeon then
            local room3 = dungeon:FindFirstChild("room3")
            if room3 then
                local enemyFolder = room3:FindFirstChild("enemyFolder")
                if enemyFolder then
                    tether = enemyFolder:FindFirstChild("Tether")
                end
            end
        end
        
        if currentTarget and (not currentTarget:IsDescendantOf(workspace) or currentTarget:IsDescendantOf(workspace.enemyPool)) then
            currentTarget = nil
        end
        
        local enemyFolders = getEnemyFolders()
        local priorityTarget = getPriorityTarget(enemyFolders)
        
        if azrallikHeart then
            currentTarget = azrallikHeart
        elseif odinReincarnation then
            currentTarget = odinReincarnation
        elseif tether then
            currentTarget = tether
        elseif priorityTarget then
            currentTarget = priorityTarget
        elseif not currentTarget or (currentTarget:FindFirstChild("Humanoid") and currentTarget.Humanoid.Health <= 0) then
            currentTarget = nil
            for _, folder in ipairs(enemyFolders) do
                currentTarget = getNextEnemy(folder)
                if currentTarget then break end
            end
            
            if not currentTarget then
                stabilizeCharacter(humanoidRootPart)
                task.wait(1)
                continue
            end
        end
        
        if currentTarget and (currentTarget:IsA("Model") or currentTarget:IsA("BasePart")) then
            local targetPart
            if currentTarget:IsA("Model") then
                targetPart = currentTarget:FindFirstChild("HumanoidRootPart")
                if not targetPart then
                    targetPart = currentTarget.PrimaryPart or currentTarget:FindFirstChildWhichIsA("BasePart")
                end
            else
                targetPart = currentTarget
            end
            
            if targetPart then
                stabilizeCharacter(humanoidRootPart)
                local currentTargetPosition = targetPart.Position
                if (currentTargetPosition - lastEnemyPosition).Magnitude > farDistanceThreshold then
                    stabilizeCharacter(humanoidRootPart)
                    task.wait(getTeleportSpeed())
                end
                lastEnemyPosition = currentTargetPosition
                
                local currentDistance = getDistance()
                local teleportOffset = Vector3.new(0, currentDistance, 0)
                local lookVector = Vector3.new(0, -1, 0)
                
                if currentTarget.Name == "Beast Master" then
                    local initialHunterBossEntry = workspace:FindFirstChild("initialHunterBossEntry")
                    if initialHunterBossEntry then
                        unanchorPlayer(character)
                        task.wait(0.1)
                        teleportTo(initialHunterBossEntry)
                        task.wait(0.1)
                        anchorPlayer(character)
                        task.wait(1.5)
                    end
                elseif currentTarget.Name == "Odin Reincarnation" then
                    unanchorPlayer(character)
                    task.wait(0.1)
                    teleportTo(currentTarget)
                    task.wait(0.1)
                    anchorPlayer(character)
                    task.wait(1.5)
                elseif currentTarget.Name == "Exalted Queensguard" or currentTarget.Name == "Adelys" or currentTarget.Name == "Sarugami" or currentTarget.Name == "Eldritch Reaver" or currentTarget.Name == "Eldritch Prophet" then
                    teleportOffset = Vector3.new(0, -currentDistance, 0)
                    lookVector = Vector3.new(0, 1, 0)
                elseif currentTarget.Name == "Corrupted Growth" then
                    currentDistance = 25
                    teleportOffset = Vector3.new(0, -currentDistance, 0)
                    lookVector = Vector3.new(0, 1, 0)
                elseif currentTarget.Name == "Voidshade" then
                    currentDistance = 28
                    local front = targetPart.CFrame.lookVector * currentDistance
                    teleportOffset = Vector3.new(front.X, 0, front.Z)
                    lookVector = targetPart.Position - (targetPart.Position + teleportOffset)
                elseif currentTarget.Name == "Tii" then
                    currentDistance = 3
                    teleportOffset = Vector3.new(0, currentDistance, 0)
                    lookVector = Vector3.new(0, -1, 0)
                elseif currentTarget.Name == "Red Hand" or currentTarget.Name == "Blue Hand" or currentTarget.Name == "Purple Hand" or currentTarget.Name == "Green Hand" then
                    currentDistance = 15
                    local heightOffset = 13
                    local forwardOffset = 8
                    local forward = targetPart.CFrame.lookVector * forwardOffset
                    teleportOffset = Vector3.new(forward.X, heightOffset, forward.Z)
                    lookVector = (targetPart.Position - (targetPart.Position + teleportOffset)).Unit
                    
                    local targetPosition = targetPart.Position + teleportOffset
                    local lookAt = targetPart.Position + lookVector
                    
                    unanchorPlayer(character)
                    task.wait(0.1)
                    humanoidRootPart.CFrame = CFrame.new(targetPosition, lookAt)
                    task.wait(0.1)
                    anchorPlayer(character)
                    task.wait(0.1)
                    continue
                elseif currentTarget.Name == "The Voidborn" then
                    local fixedPosition = Vector3.new(2392, -623, 77)
                    lookVector = (targetPart.Position - fixedPosition).Unit
                    unanchorPlayer(character)
                    task.wait(0.1)
                    humanoidRootPart.CFrame = CFrame.new(fixedPosition, targetPart.Position)
                    task.wait(0.1)
                    anchorPlayer(character)
                    task.wait(0.5)
                    continue
                end
                
                local targetPosition = targetPart.Position + teleportOffset
                local lookAt = targetPart.Position + lookVector
                unanchorPlayer(character)
                task.wait(0.1)
                humanoidRootPart.CFrame = CFrame.new(targetPosition, lookAt)
                task.wait(0.1)
                anchorPlayer(character)
            end
        else
            stabilizeCharacter(humanoidRootPart)
            task.wait(1)
            continue
        end
        
        task.wait(0.1)
        
        if currentTarget == azrallikHeart and not workspace:FindFirstChild("Azrallik's Heart") then
            currentTarget = nil
        end
        if currentTarget == odinReincarnation and not workspace:FindFirstChild("Odin Reincarnation") then
            currentTarget = nil
        end
        if currentTarget == tether and not workspace:FindFirstChild("Tether") then
            currentTarget = nil
        end
    end
end
               
    local function getAutofarmEnemyFolders()
        local enemyFolders = {}
        local dungeon = workspace:FindFirstChild("dungeon")
        if dungeon then
            for _, room in ipairs(dungeon:GetChildren()) do
                local enemyFolder = room:FindFirstChild("enemyFolder")
                if enemyFolder and #enemyFolder:GetChildren() > 0 then
                    table.insert(enemyFolders, enemyFolder)
                end
            end
        end
        return enemyFolders
    end

    local function getWavefarmEnemyFolders()
        local enemiesFolder = workspace:FindFirstChild("enemies")
        return enemiesFolder and #enemiesFolder:GetChildren() > 0 and {enemiesFolder} or {}
    end

    local function tweenButton(button, property, value)
        TweenService:Create(button, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {[property] = value}):Play()
    end

    local function saveAutofarmState()
        local saveFolder = "kisave"
        if not isfolder(saveFolder) then makefolder(saveFolder) end
        writefile(saveFolder .. "/autofarm_state.txt", tostring(isAutofarming))
    end

    local function loadAutofarmState()
        local saveFolder, fileName = "kisave", "kisave/autofarm_state.txt"
        return isfolder(saveFolder) and isfile(fileName) and readfile(fileName) == "true"
    end
    
    local function saveBonusBossState(state)
    local saveFolder = "kisave"
    if not isfolder(saveFolder) then makefolder(saveFolder) end
    writefile(saveFolder .. "/bonus_boss_state.txt", tostring(state))
end

local function loadBonusBossState()
    local saveFolder, fileName = "kisave", "kisave/bonus_boss_state.txt"
    return isfolder(saveFolder) and isfile(fileName) and readfile(fileName) == "true"
end

    local useSkills = false
    local holdSkills = false

    local function saveUseSkillsState()
        local saveFolder = "kisave"
        if not isfolder(saveFolder) then makefolder(saveFolder) end
        writefile(saveFolder .. "/use_skills_state.txt", tostring(useSkills))
    end

    local function loadUseSkillsState()
        local saveFolder, fileName = "kisave", "kisave/use_skills_state.txt"
        return isfolder(saveFolder) and isfile(fileName) and readfile(fileName) == "true"
    end
    
    useSkillsSwitch.MouseButton1Click:Connect(function()
    useSkills = not useSkills
    useSkillsSwitch.Text = useSkills and "Use Skills: ON" or "Use Skills: OFF"
    tweenButton(useSkillsSwitch, "BackgroundColor3", useSkills and Color3.fromRGB(0, 120, 215) or Color3.fromRGB(45, 45, 45))
    saveUseSkillsState()
end)

    useSkills = loadUseSkillsState()
    useSkillsSwitch.Text = useSkills and "Use Skills: ON" or "Use Skills: OFF"
    tweenButton(useSkillsSwitch, "BackgroundColor3", useSkills and Color3.fromRGB(0, 120, 215) or Color3.fromRGB(45, 45, 45))

local function saveHoldSkillsState()
    local saveFolder = "kisave"
    if not isfolder(saveFolder) then makefolder(saveFolder) end
    writefile(saveFolder .. "/hold_skills_state.txt", tostring(holdSkills))
end

local function loadHoldSkillsState()
    local saveFolder, fileName = "kisave", "kisave/hold_skills_state.txt"
    return isfolder(saveFolder) and isfile(fileName) and readfile(fileName) == "true"
end

holdSkillsSwitch.MouseButton1Click:Connect(function()
    holdSkills = not holdSkills
    holdSkillsSwitch.Text = holdSkills and "Hold Skills: ON" or "Hold Skills: OFF"
    tweenButton(holdSkillsSwitch, "BackgroundColor3", holdSkills and Color3.fromRGB(0, 120, 215) or Color3.fromRGB(45, 45, 45))
    saveHoldSkillsState()
end)

holdSkills = loadHoldSkillsState()
holdSkillsSwitch.Text = holdSkills and "Hold Skills: ON" or "Hold Skills: OFF"
tweenButton(holdSkillsSwitch, "BackgroundColor3", holdSkills and Color3.fromRGB(0, 120, 215) or Color3.fromRGB(45, 45, 45))

local function setupButton(button, farmType, getEnemyFolders)
    button.MouseEnter:Connect(function()
        tweenButton(button, "BackgroundColor3", Color3.fromRGB(60, 60, 60))
    end)
    button.MouseLeave:Connect(function()
        if (farmType == "Autofarm" and not isAutofarming) or (farmType == "Wavefarm" and not isWavefarming) then
            tweenButton(button, "BackgroundColor3", Color3.fromRGB(45, 45, 45))
        end
    end)
    button.MouseButton1Click:Connect(function()
            if farmType == "Autofarm" and isWavefarming then
                showNotification("Error", "Cannot start Autofarm while Wavefarm is active")
                return
            elseif farmType == "Wavefarm" and isAutofarming then
                showNotification("Error", "Cannot start Wavefarm while Autofarm is active")
                return
            end

            local enemyFolders = getEnemyFolders()
            if #enemyFolders == 0 then
                showNotification("Error", "Cannot start " .. farmType .. " in this location")
                isAutofarming = false
                saveAutofarmState()
                return
            end

            if farmType == "Autofarm" then
                isAutofarming = not isAutofarming
                saveAutofarmState()
            else
                isWavefarming = not isWavefarming
            end

            local isActive = farmType == "Autofarm" and isAutofarming or isWavefarming

            if isActive then
                tweenButton(button, "BackgroundColor3", Color3.fromRGB(0, 120, 215))
                showNotification(farmType, farmType .. " started")
                originalGravity = workspace.Gravity
                workspace.Gravity = 0
                if player.Character and player.Character:FindFirstChild("Humanoid") then
                    player.Character.Humanoid.PlatformStand = true
                end

                if farmType == "Autofarm" then
                    ReplicatedStorage.remotes.changeStartValue:FireServer()
                end

                coroutine.wrap(function() farm(getEnemyFolders) end)()

                if farmType == "Autofarm" then
                    coroutine.wrap(function()
                        task.wait(2)
                        frame.Visible = false
                        isGuiVisible = false
                    end)()
                end
            else
                tweenButton(button, "BackgroundColor3", Color3.fromRGB(45, 45, 45))
                showNotification(farmType, farmType .. " stopped")
                currentTarget = nil
                workspace.Gravity = originalGravity
                if player.Character and player.Character:FindFirstChild("Humanoid") then
                    player.Character.Humanoid.PlatformStand = false
                end

            end
    end)
end

setupButton(autofarmButton, "Autofarm", getAutofarmEnemyFolders)
setupButton(wavefarmButton, "Wavefarm", getWavefarmEnemyFolders)

local function checkBossHealth()
    local ts = game:GetService("TeleportService")

    local function checkHealth()
        local Hela = workspace.dungeon.bossRoom.enemyFolder:FindFirstChild("Hela")
        local Goliath = workspace.dungeon.bossRoom.enemyFolder:FindFirstChild("Goliath")
        if not Hela and not Goliath then
            wait(2)
            repeat
                ts:Teleport(2414851778)
                wait(2)
            until false
        end
    end

coroutine.wrap(function()
    while true do
        checkHealth()
        wait(0.2)
    end
    end)()
end

local isBonusBossActive = loadBonusBossState()
bonusBossButton.Text = isBonusBossActive and "Bonus Boss: ON" or "Bonus Boss: OFF"
tweenButton(bonusBossButton, "BackgroundColor3", isBonusBossActive and Color3.fromRGB(0, 120, 215) or Color3.fromRGB(45, 45, 45))

bonusBossButton.MouseButton1Click:Connect(function()
    isBonusBossActive = not isBonusBossActive
    bonusBossButton.Text = isBonusBossActive and "Bonus Boss: ON" or "Bonus Boss: OFF"
    tweenButton(bonusBossButton, "BackgroundColor3", isBonusBossActive and Color3.fromRGB(0, 120, 215) or Color3.fromRGB(45, 45, 45))
    saveBonusBossState(isBonusBossActive)
end)

local blackscreenGui = Instance.new("ScreenGui")
blackscreenGui.Name ="blackscreenGui"
blackscreenGui.IgnoreGuiInset = true
blackscreenGui.Parent = player:WaitForChild("PlayerGui")

local blackFrame = Instance.new("Frame")
blackFrame.Name = "blackframe"
blackFrame.Size = UDim2.new(1, 0, 1, 0)
blackFrame.BackgroundColor3 = Color3.new(0, 0, 0)
blackFrame.BorderSizePixel = 0
blackFrame.Parent = blackscreenGui
blackFrame.Visible = false

blackscreenGui.ResetOnSpawn = false
blackscreenGui.DisplayOrder = -1

disableRenderButton.MouseButton1Click:Connect(function()
    isRenderDisabled = not isRenderDisabled
    if isRenderDisabled then
        tweenButton(disableRenderButton, "BackgroundColor3", Color3.fromRGB(0, 120, 215))
        disableRenderButton.Text = "Enable Render"
        showNotification("Render Disabled", "Rendering has been disabled")
            RunService:Set3dRenderingEnabled(false)
            blackscreenGui.blackframe.Visible = true
    else
        tweenButton(disableRenderButton, "BackgroundColor3", Color3.fromRGB(45, 45, 45))
        disableRenderButton.Text = "Disable Render"
        RunService:Set3dRenderingEnabled(true)
        showNotification("Render Enabled", "Rendering has been enabled")
        blackscreenGui.blackframe.Visible = false
    end
    saveRenderState()
end)

local saveFolder = "kisave"
if not isfolder(saveFolder) then
    makefolder(saveFolder)
end

local function saveGreggFarmState()
    writefile(saveFolder .. "/gregg_farm_state.txt", tostring(isGreggFarmEnabled))
end

local function loadGreggFarmState()
    local fileName = saveFolder .. "/gregg_farm_state.txt"
    return isfolder(saveFolder) and isfile(fileName) and readfile(fileName) == "true"
end

greggfarmButton.MouseButton1Click:Connect(function()
    isGreggFarmEnabled = not isGreggFarmEnabled

    if isGreggFarmEnabled then
        tweenButton(greggfarmButton, "BackgroundColor3", Color3.fromRGB(0, 120, 215))
        showNotification("Gregg Farm", "Use this in hardcore mode for maximum effect")

        spawn(function()
            while isGreggFarmEnabled do
                local screenGui = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("CrossDungeonGregg")
                if screenGui then
                    local greggRewards = screenGui:FindFirstChild("greggRewards")
                    if greggRewards and greggRewards.Visible then
                        game:GetService("Players").LocalPlayer.Character:BreakJoints()
                    end
                end
                wait(0.1)
            end
        end)
    else
        tweenButton(greggfarmButton, "BackgroundColor3", Color3.fromRGB(45, 45, 45))
    end

    saveGreggFarmState()
end)

if loadGreggFarmState() then
    isGreggFarmEnabled = true
    tweenButton(greggfarmButton, "BackgroundColor3", Color3.fromRGB(0, 120, 215))
    
    spawn(function()
        while isGreggFarmEnabled do
            local screenGui = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("CrossDungeonGregg")
            if screenGui then
                local greggRewards = screenGui:FindFirstChild("greggRewards")
                if greggRewards and greggRewards.Visible then
                    game:GetService("Players").LocalPlayer.Character:BreakJoints()
                end
            end
            wait(0.1)
        end
    end)
else
    isGreggFarmEnabled = false
    tweenButton(greggfarmButton, "BackgroundColor3", Color3.fromRGB(45, 45, 45))
end

local function createStatsButton(parent, position)
    local statsButton = Instance.new("TextButton")
    statsButton.Size = UDim2.new(0.3, 0, 0, 25)
    statsButton.Position = position
    statsButton.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    statsButton.BackgroundTransparency = 0.5
    statsButton.Font = Enum.Font.GothamSemibold
    statsButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    statsButton.TextSize = 10
    statsButton.Text = "AutoStats"
    statsButton.Parent = parent
    Instance.new("UICorner", statsButton).CornerRadius = UDim.new(0, 8)
    return statsButton
end

local statsButton = createStatsButton(frame, UDim2.new(0.65, 0, 0, 220))

local statsList = Instance.new("Frame")
statsList.Size = UDim2.new(0, 100, 0, 90)
statsList.Position = UDim2.new(1, 5, -1, -5)
statsList.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
statsList.BackgroundTransparency = 0.5
statsList.Visible = false
statsList.Parent = statsButton

Instance.new("UICorner", statsList).CornerRadius = UDim.new(0, 8)

local function createStatButton(parent, text, position)
    local button = Instance.new("TextButton")
    button.Size = UDim2.new(0.9, 0, 0, 25)
    button.Position = position
    button.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    button.BackgroundTransparency = 0.5
    button.Font = Enum.Font.GothamSemibold
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.TextSize = 10
    button.Text = text
    button.Parent = parent
    Instance.new("UICorner", button).CornerRadius = UDim.new(0, 8)
    return button
end

local spellButton = createStatButton(statsList, "Spell", UDim2.new(0.05, 0, 0, 5))
local staminaButton = createStatButton(statsList, "Stamina", UDim2.new(0.05, 0, 0, 35))
local physicsButton = createStatButton(statsList, "Physics", UDim2.new(0.05, 0, 0, 65))

local activeStatButton = nil

local function toggleStatButton(button, statType)
    if activeStatButton == button then
        tweenButton(button, "BackgroundColor3", Color3.fromRGB(45, 45, 45))
        activeStatButton = nil
        saveSelectedStat("none")
    else
        if activeStatButton then
            tweenButton(activeStatButton, "BackgroundColor3", Color3.fromRGB(45, 45, 45))
        end
        tweenButton(button, "BackgroundColor3", Color3.fromRGB(0, 120, 215))
        activeStatButton = button
        saveSelectedStat(statType)
    end
end

local function setActiveStat(statType)
    local button
    if statType == "spellPower" then
        button = spellButton
    elseif statType == "stamina" then
        button = staminaButton
    elseif statType == "physicalPower" then
        button = physicsButton
    end

    if button then
        toggleStatButton(button, statType)
    end
end

local savedStat = loadSelectedStat()
if savedStat then
    setActiveStat(savedStat)
end

spellButton.MouseButton1Click:Connect(function() toggleStatButton(spellButton, "spellPower") end)
staminaButton.MouseButton1Click:Connect(function() toggleStatButton(staminaButton, "stamina") end)
physicsButton.MouseButton1Click:Connect(function() toggleStatButton(physicsButton, "physicalPower") end)

statsButton.MouseButton1Click:Connect(function()
    statsList.Visible = not statsList.Visible
end)

local function sendStatRemote(statType)
   local symbols = {"#", "$", "%"}
   
   for _, symbol in ipairs(symbols) do
       local args = {
           [1] = {
               [1] = {
                   [1] = "\001",
                   [2] = {
                       ["stat"] = statType,
                       ["amount"] = 1
                   }
               },
               [2] = symbol
           }
       }
       game:GetService("ReplicatedStorage").dataRemoteEvent:FireServer(unpack(args))
       wait(1.5)
   end
end

coroutine.wrap(function()
    while true do
        if activeStatButton then
            local statType
            if activeStatButton == spellButton then
                statType = "spellPower"
            elseif activeStatButton == staminaButton then
                statType = "stamina"
            elseif activeStatButton == physicsButton then
                statType = "physicalPower"
            end
            
            if statType and isAutofarming == true or isWavefarming == true then
                sendStatRemote(statType)
            end
        end
        task.wait(1)
    end
end)()

local function update(input)
    if activeSlider then return end
    local delta = input.Position - dragStart
    local newPosition = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    TweenService:Create(frame, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Position = newPosition}):Play()
end

frame.InputBegan:Connect(function(input)
    if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) and not activeSlider then
        isDraggingGUI = true
        dragging, dragStart, startPos = true, input.Position, frame.Position

        local connection
        connection = UserInputService.InputEnded:Connect(function(endInput)
            if endInput.UserInputType == Enum.UserInputType.MouseButton1 or endInput.UserInputType == Enum.UserInputType.Touch then
                isDraggingGUI = false
                dragging = false
                connection:Disconnect()
            end
        end)
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        update(input)
    end
end)

RunService.Heartbeat:Connect(function()
    if isAutofarming or isWavefarming then
        local character = player.Character
        if character and character:FindFirstChild("HumanoidRootPart") then
            character.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
        end
    end
end)

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

local function onCharacterAdded(newCharacter)
   player.CameraMaxZoomDistance = 128
   player.CameraMinZoomDistance = 16
   
   newCharacter.ChildAdded:Connect(function(child)
       if child:IsA("Model") and (isAutofarming or isWavefarming) then
           task.wait(0.1)
           if newCharacter:FindFirstChild("HumanoidRootPart") then
               newCharacter.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
           end
       end
   end)
   
   local humanoid = newCharacter:WaitForChild("Humanoid")
   
   humanoid.Died:Connect(function()
       resetKeyPresses()
       player.CameraMaxZoomDistance = 0
       player.CameraMinZoomDistance = 0
   end)
   
   humanoid.HealthChanged:Connect(function(health)
       if health <= 0 then
           resetKeyPresses()
           player.CameraMaxZoomDistance = 0
           player.CameraMinZoomDistance = 0
       end
   end)
end

player.CharacterAdded:Connect(onCharacterAdded)

if player.Character then
   onCharacterAdded(player.Character)
end

local toggleButton = Instance.new("ImageButton")
toggleButton.Size = UDim2.new(0, 40, 0, 40)
toggleButton.Position = UDim2.new(0.5, -20, 0, 10)
toggleButton.AnchorPoint = Vector2.new(0.5, 0)
toggleButton.BackgroundTransparency = 1
toggleButton.Image = "rbxassetid://7191235918"
toggleButton.ImageTransparency = 0.3
toggleButton.Parent = gui

local toggleButtonCorner = Instance.new("UICorner")
toggleButtonCorner.CornerRadius = UDim.new(0, 30)
toggleButtonCorner.Parent = toggleButton

local toggleButtonText = Instance.new("TextLabel")
toggleButtonText.Size = UDim2.new(1, 0, 1, 0)
toggleButtonText.BackgroundTransparency = 1
toggleButtonText.Text = "K"
toggleButtonText.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleButtonText.Font = Enum.Font.GothamBold
toggleButtonText.TextSize = 18
toggleButtonText.Parent = toggleButton

local isGuiVisible = true
toggleButton.MouseButton1Click:Connect(function()
    isGuiVisible = not isGuiVisible
    frame.Visible = isGuiVisible
    MainFrame.Visible = false
    PrimaryFrame.Visible = false
end)

local draggingToggle, dragStartToggle, startPosToggle

toggleButton.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        draggingToggle = true
        dragStartToggle = input.Position
        startPosToggle = toggleButton.Position

        local connection
        connection = UserInputService.InputEnded:Connect(function(endInput)
            if endInput.UserInputType == Enum.UserInputType.MouseButton1 or endInput.UserInputType == Enum.UserInputType.Touch then
                draggingToggle = false
                connection:Disconnect()
            end
        end)
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if draggingToggle and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        local delta = input.Position - dragStartToggle
        local newPosition = UDim2.new(startPosToggle.X.Scale, startPosToggle.X.Offset + delta.X, startPosToggle.Y.Scale, startPosToggle.Y.Offset + delta.Y)
        toggleButton.Position = newPosition
    end
end)

local function sendSkipRemote()
   local symbols = {"\186"}
   
   for _, symbol in ipairs(symbols) do
       local args = {
           [1] = {
               [1] = {
                   ["\003"] = "skip"
               },
               [2] = symbol
           }
       }
       game:GetService("ReplicatedStorage").dataRemoteEvent:FireServer(unpack(args))
       wait(1.5)
   end
end

local function watchForCutscene()
    local player = game.Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")
    
    local function onChildAdded(child)
        if child.Name == "cutscene" and child:IsA("ScreenGui") then
            child:GetPropertyChangedSignal("Enabled"):Connect(function()
                if child.Enabled then
                    sendSkipRemote()
                end
            end)
        end
    end

    playerGui.ChildAdded:Connect(onChildAdded)
    
    for _, child in ipairs(playerGui:GetChildren()) do
        onChildAdded(child)
    end
end

coroutine.wrap(watchForCutscene)()

local function voteWithSymbol(symbol, voteType)
    local args = {
        [1] = {
            [1] = {
                ["\003"] = "vote",
                vote = voteType == "Bonus" and "bonus" or true
            },
            [2] = symbol
        }
    }
    
    ReplicatedStorage.dataRemoteEvent:FireServer(unpack(args))
end

local function waitForRetryVote()
    while true do
        local retryVoteGui = player.PlayerGui:FindFirstChild("RetryVote")
        if retryVoteGui and retryVoteGui.Enabled then
            local frame = retryVoteGui:FindFirstChild("Frame")
            if frame then
                local bonusButton = frame:FindFirstChild("Bonus")
                if bonusButton and bonusButton.Visible then
                    return "Bonus"
                else
                    return "Retry"
                end
            end
        end
        task.wait(0.5)
    end
end

local function exhaustiveVote()
    local symbols = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=[]{}|;:,.<>?/`~'\""
    local specialChars = string.char(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)
    
    symbols = symbols .. specialChars
    
    while true do
        local voteType = waitForRetryVote()
        
        if voteType == "Bonus" and isBonusBossActive then
            voteType = "Bonus"
        else
            voteType = "Retry"
        end
        
        for i = 1, #symbols do
            local symbol = symbols:sub(i, i)
            voteWithSymbol(symbol, voteType)
            task.wait(0)
            
            local retryVoteGui = player.PlayerGui:FindFirstChild("RetryVote")
            if not retryVoteGui or not retryVoteGui.Enabled then
                break
            end
        end
        
        task.wait(1)
    end
end

coroutine.wrap(exhaustiveVote)()

local noclipConnection
local function enableNoclip()
    if noclipConnection then return end
    noclipConnection = RunService.Stepped:Connect(function()
        if player.Character then
            for _, part in pairs(player.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end
    end)
end

local function disableNoclip()
    if noclipConnection then
        noclipConnection:Disconnect()
        noclipConnection = nil
    end
end

local function updateNoclip()
    if isAutofarming or isWavefarming then
        enableNoclip()
    else
        disableNoclip()
    end
end

RunService.Heartbeat:Connect(updateNoclip)

local ts = game:GetService("TeleportService")

local function activateSkills()
    local player = game:GetService("Players").LocalPlayer
    local virtualInputManager = game:GetService("VirtualInputManager")
    local isHolding = false
    
    while true do
        if (useSkills or holdSkills) and (isAutofarming or isWavefarming or isAutofarmv2) then
            local character = player.Character
            if character and character:FindFirstChild("HumanoidRootPart") and character:FindFirstChild("Humanoid") and character.Humanoid.Health > 0 then
                local rootPart = character.HumanoidRootPart
                local shouldUseSkills = false
                
                if currentTarget and currentTarget:FindFirstChild("HumanoidRootPart") and currentTarget:FindFirstChild("Humanoid") then
                    local targetHumanoid = currentTarget:FindFirstChild("Humanoid")
                    if targetHumanoid and targetHumanoid.Health > 0 then
                        local targetRootPart = currentTarget.HumanoidRootPart
                        local distance = (rootPart.Position - targetRootPart.Position).Magnitude
                        
                        if isAutofarmv2 then
                            shouldUseSkills = distance <= 70
                        else
                            if currentTarget.Name == "Corrupted Growth" then
                                shouldUseSkills = distance <= 35
                            elseif currentTarget.Name == "Goliath" or currentTarget.Name == "Hela" then
                                shouldUseSkills = distance <= 35
                                checkBossHealth()
                            elseif currentTarget.Name == "Voidshade" then
                                shouldUseSkills = distance <= 35
                            elseif currentTarget.Name == "The Voidborn" then
                                shouldUseSkills = distance <= 100
                            elseif currentTarget.Name == "Red Hand" or
                                   currentTarget.Name == "Blue Hand" or
                                   currentTarget.Name == "Purple Hand" or
                                   currentTarget.Name == "Green Hand" then
                                shouldUseSkills = distance <= 50
                            else
                                shouldUseSkills = distance <= getDistance() + 10
                            end
                        end
                    end
                end
                
                if shouldUseSkills then
                    if holdSkills then
                        virtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game)
                        virtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
                        virtualInputManager:SendKeyEvent(true, Enum.KeyCode.Q, false, game)
                        virtualInputManager:SendKeyEvent(false, Enum.KeyCode.Q, false, game)
                    elseif useSkills then
                        pcall(function()
                            if player.Backpack:GetChildren()[1]:FindFirstChild("spellEvent") then
                                player.Backpack:GetChildren()[1].spellEvent:FireServer()
                            end
                            if player.Backpack:GetChildren()[1]:FindFirstChild("abilityEvent") then
                                player.Backpack:GetChildren()[1].abilityEvent:FireServer()
                            end
                            if player.Backpack:GetChildren()[2]:FindFirstChild("spellEvent") then
                                player.Backpack:GetChildren()[2].spellEvent:FireServer()
                            end
                            if player.Backpack:GetChildren()[2]:FindFirstChild("abilityEvent") then
                                player.Backpack:GetChildren()[2].abilityEvent:FireServer()
                            end
                        end)
                    end
                end
            else
                resetKeyPresses()
            end
        end
        task.wait(0)
    end
end

coroutine.wrap(activateSkills)()
coroutine.wrap(activateSkills)()

coroutine.wrap(function()
   task.wait(0.1)
   ReplicatedStorage.remotes.changeStartValue:FireServer()
   local savedAutofarmState = loadAutofarmState()
   if savedAutofarmState then
       local enemyFolders = getAutofarmEnemyFolders()
       if #enemyFolders > 0 then
           isAutofarming = true
           tweenButton(autofarmButton, "BackgroundColor3", Color3.fromRGB(0, 120, 215))
           showNotification("Autofarm", "Autofarm started")
           originalGravity = workspace.Gravity
           workspace.Gravity = 0
           if player.Character and player.Character:FindFirstChild("Humanoid") then
               player.Character.Humanoid.PlatformStand = true
           end
           
           task.wait(2)
           frame.Visible = false
           isGuiVisible = false
           
           farm(getAutofarmEnemyFolders)
       else
           showNotification("Autofarm", "Cannot start Autofarm in this location")
       end
   end
end)()

coroutine.wrap(function() 
    task.wait(0.1) 
    isRenderDisabled = loadRenderState()
    if isRenderDisabled then 
        RunService:Set3dRenderingEnabled(false) 
        blackscreenGui.blackframe.Visible = true
        if disableRenderButton then 
            tweenButton(disableRenderButton, "BackgroundColor3", Color3.fromRGB(0, 120, 215)) 
            disableRenderButton.Text = "Enable Render" 
        end 
    else 
        RunService:Set3dRenderingEnabled(true) 
        blackscreenGui.blackframe.Visible = false
        if disableRenderButton then 
            tweenButton(disableRenderButton, "BackgroundColor3", Color3.fromRGB(45, 45, 45)) 
            disableRenderButton.Text = "Disable Render" 
        end 
    end 
end)()

local Workspace = game:GetService("Workspace")

Workspace.ChildAdded:Connect(function(child)
    if child.ClassName == "Beam" then
        child.Enabled = false
    end
    
    if child:IsA("BasePart") or child:IsA("Part") then
        child.Transparency = 1
        child:Destroy()
    end
         
    if child:IsA("Model") then
        local humanoid = child:FindFirstChild("Humanoid")
        if not humanoid then
            local parts = child:GetDescendants()
            for _, part in ipairs(parts) do
                if part:IsA("BasePart") or part:IsA("Part") then
                    part.Transparency = 1
                end
            end
        end
    end
end)

local autoDungeonButton = createButton(frame, "Auto Dungeon", UDim2.new(0.03, 0, 0, 35))
autoDungeonButton.Size = UDim2.new(0.2, 0, 0, 25)

local isAutoDungeon = false
local useHardcore = false
local saveFolder = "kisave"

local function saveAutoDungeonState(state)
    if not isfolder(saveFolder) then makefolder(saveFolder) end
    writefile(saveFolder .. "/auto_dungeon_state.txt", tostring(state))
end

local function saveHardcoreState(state)
    if not isfolder(saveFolder) then makefolder(saveFolder) end
    writefile(saveFolder .. "/auto_dungeon_hardcore.txt", tostring(state))
end

local function loadAutoDungeonState()
    if isfolder(saveFolder) and isfile(saveFolder .. "/auto_dungeon_state.txt") then
        return readfile(saveFolder .. "/auto_dungeon_state.txt") == "true"
    end
    return false
end

local function loadHardcoreState()
    if isfolder(saveFolder) and isfile(saveFolder .. "/auto_dungeon_hardcore.txt") then
        return readfile(saveFolder .. "/auto_dungeon_hardcore.txt") == "true"
    end
    return false
end

isAutoDungeon = loadAutoDungeonState()
useHardcore = loadHardcoreState()

if isAutoDungeon then
    autoDungeonButton.BackgroundColor3 = Color3.fromRGB(0, 120, 215)
end

local dungeonLevels = {
    ["Desert Temple"] = {
        {level = 1, difficulty = "Easy"},
        {level = 5, difficulty = "Medium"}, 
        {level = 15, difficulty = "Hard"}
    },
    ["Winter Outpost"] = {
        {level = 30, difficulty = "Easy"},
        {level = 40, difficulty = "Medium"},
        {level = 50, difficulty = "Hard"}
    },
    ["Pirate Island"] = {
        {level = 60, difficulty = "Insane"},
        {level = 65, difficulty = "Nightmare"}
    },
    ["King's Castle"] = {
        {level = 70, difficulty = "Insane"},
        {level = 75, difficulty = "Nightmare"}
    },
    ["The Underworld"] = {
        {level = 80, difficulty = "Insane"},
        {level = 85, difficulty = "Nightmare"}
    },
    ["Samurai Palace"] = {
        {level = 90, difficulty = "Insane"},
        {level = 95, difficulty = "Nightmare"}
    },
    ["The Canals"] = {
        {level = 100, difficulty = "Insane"},
        {level = 105, difficulty = "Nightmare"}
    },
    ["Ghastly Harbor"] = {
        {level = 110, difficulty = "Insane"},
        {level = 115, difficulty = "Nightmare"}
    },
    ["Steampunk Sewers"] = {
        {level = 120, difficulty = "Insane"},
        {level = 125, difficulty = "Nightmare"}
    },
    ["Orbital Outpost"] = {
        {level = 135, difficulty = "Insane"},
        {level = 140, difficulty = "Nightmare"}
    },
    ["Volcanic Chambers"] = {
        {level = 150, difficulty = "Insane"},
        {level = 155, difficulty = "Nightmare"}
    },
    ["Aquatic Temple"] = {
        {level = 160, difficulty = "Insane"},
        {level = 165, difficulty = "Nightmare"}
    },
    ["Enchanted Forest"] = {
        {level = 170, difficulty = "Insane"},
        {level = 175, difficulty = "Nightmare"}
    },
    ["Northern Lands"] = {
        {level = 180, difficulty = "Insane"},
        {level = 185, difficulty = "Nightmare"}
    },
    ["Gilded Skies"] = {
        {level = 190, difficulty = "Insane"},
        {level = 195, difficulty = "Nightmare"}
    },
    ["Yokai Peak"] = {
        {level = 200, difficulty = "Insane"},
        {level = 205, difficulty = "Nightmare"}
    },
    ["Abyssal Void"] = {
        {level = 210, difficulty = "Insane"},
        {level = 215, difficulty = "Nightmare"}
    }
}

local function saveCurrentDungeon(dungeon)
    writefile(saveFolder .. "/current_dungeon.txt", dungeon)
end

local function getSavedDungeon()
    if isfile(saveFolder .. "/current_dungeon.txt") then
        return readfile(saveFolder .. "/current_dungeon.txt")
    end
    return nil
end

local function saveCurrentDifficulty(difficulty)
    writefile(saveFolder .. "/current_difficulty.txt", difficulty)
end

local function getSavedDifficulty()
    if isfile(saveFolder .. "/current_difficulty.txt") then
        return readfile(saveFolder .. "/current_difficulty.txt")
    end
    return nil
end

local function getDungeonAndDifficultyForLevel(currentLevel)    
    local bestDungeon = nil
    local bestDifficulty = nil
    local smallestDiff = math.huge
    
    for dungeonName, difficulties in pairs(dungeonLevels) do
        for _, difficultyData in ipairs(difficulties) do
            if currentLevel >= difficultyData.level then
                local levelDiff = currentLevel - difficultyData.level
                if levelDiff < smallestDiff then
                    smallestDiff = levelDiff
                    bestDungeon = dungeonName
                    bestDifficulty = difficultyData.difficulty
                end
            end
        end
    end
    
    return bestDungeon, bestDifficulty
end

local function shouldTeleportToLobby(currentLevel, currentDungeon, currentDifficulty)
    if not currentDungeon or not currentDifficulty then return true end
    
    local savedDungeon = getSavedDungeon()
    local savedDifficulty = getSavedDifficulty()
    
    if savedDungeon ~= currentDungeon or savedDifficulty ~= currentDifficulty then
        saveCurrentDungeon(currentDungeon)
        saveCurrentDifficulty(currentDifficulty)
        return true
    end
    return false
end

local function createDungeon(dungeon, difficulty, useHardcoreMode)
    if not dungeon or not difficulty then return end
    
    local args = {
        [1] = dungeon,
        [2] = difficulty,
        [3] = 0,
        [4] = useHardcoreMode,
        [5] = false,
        [6] = false
    }
    
    ReplicatedStorage:WaitForChild("remotes"):WaitForChild("createLobby"):InvokeServer(unpack(args))
    wait(1)
    ReplicatedStorage:WaitForChild("remotes"):WaitForChild("startDungeon"):FireServer()
end

local function createHardcorePrompt()
    local promptFrame = Instance.new("Frame")
    promptFrame.Size = UDim2.new(0, 300, 0, 150)
    promptFrame.Position = UDim2.new(0.5, -150, 0.5, -75)
    promptFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    promptFrame.BackgroundTransparency = 0.3
    promptFrame.BorderSizePixel = 0
    promptFrame.Parent = game.CoreGui:FindFirstChild("RobloxGui")
    
    local cornerRadius = Instance.new("UICorner")
    cornerRadius.CornerRadius = UDim.new(0, 12)
    cornerRadius.Parent = promptFrame
    
    local shadow = Instance.new("ImageLabel")
    shadow.Size = UDim2.new(1, 20, 1, 20)
    shadow.Position = UDim2.new(0, -10, 0, -10)
    shadow.BackgroundTransparency = 1
    shadow.Image = "rbxassetid://5554236805"
    shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
    shadow.ImageTransparency = 0.6
    shadow.ScaleType = Enum.ScaleType.Slice
    shadow.SliceCenter = Rect.new(23, 23, 277, 277)
    shadow.ZIndex = 1
    shadow.Parent = promptFrame
    
    local textLabel = Instance.new("TextLabel")
    textLabel.Size = UDim2.new(1, 0, 0.5, 0)
    textLabel.Position = UDim2.new(0, 0, 0, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.Font = Enum.Font.GothamBold
    textLabel.TextSize = 22
    textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    textLabel.Text = "Use Hardcore?"
    textLabel.ZIndex = 2
    textLabel.Parent = promptFrame
    
    local yesButton = Instance.new("TextButton")
    yesButton.Size = UDim2.new(0.4, 0, 0.3, 0)
    yesButton.Position = UDim2.new(0.1, 0, 0.6, 0)
    yesButton.BackgroundColor3 = Color3.fromRGB(0, 170, 0)
    yesButton.BackgroundTransparency = 0.2
    yesButton.Font = Enum.Font.GothamSemibold
    yesButton.TextSize = 18
    yesButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    yesButton.Text = "Yes"
    yesButton.ZIndex = 2
    yesButton.Parent = promptFrame
    
    local yesCorner = Instance.new("UICorner")
    yesCorner.CornerRadius = UDim.new(0, 8)
    yesCorner.Parent = yesButton
    
    local noButton = Instance.new("TextButton")
    noButton.Size = UDim2.new(0.4, 0, 0.3, 0)
    noButton.Position = UDim2.new(0.5, 0, 0.6, 0)
    noButton.BackgroundColor3 = Color3.fromRGB(170, 0, 0)
    noButton.BackgroundTransparency = 0.2
    noButton.Font = Enum.Font.GothamSemibold
    noButton.TextSize = 18
    noButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    noButton.Text = "No"
    noButton.ZIndex = 2
    noButton.Parent = promptFrame
    
    local noCorner = Instance.new("UICorner")
    noCorner.CornerRadius = UDim.new(0, 8)
    noCorner.Parent = noButton
    
    local result = nil
    
    yesButton.MouseButton1Click:Connect(function()
        result = true
        promptFrame:Destroy()
    end)
    
    noButton.MouseButton1Click:Connect(function()
        result = false
        promptFrame:Destroy()
    end)
    
    while result == nil do
        wait(0.1)
    end
    
    return result
end

autoDungeonButton.MouseButton1Click:Connect(function()
    if not isAutoDungeon then
        local hardcoreChoice = createHardcorePrompt()
        useHardcore = hardcoreChoice
        saveHardcoreState(useHardcore)
    end
    
    isAutoDungeon = not isAutoDungeon
    autoDungeonButton.BackgroundColor3 = isAutoDungeon and Color3.fromRGB(0, 120, 215) or Color3.fromRGB(45, 45, 45)
    saveAutoDungeonState(isAutoDungeon)
    
    if isAutoDungeon then
        coroutine.wrap(function()
            while isAutoDungeon do
                wait(0.1)
                local currentLevel = game.Players.LocalPlayer.leaderstats.Level.Value
                local currentPlaceID = game.PlaceId
                local currentDungeon, currentDifficulty = getDungeonAndDifficultyForLevel(currentLevel)
                
                if currentPlaceID == 2414851778 then
                    saveCurrentDungeon(currentDungeon)
                    saveCurrentDifficulty(currentDifficulty)
                    createDungeon(currentDungeon, currentDifficulty, useHardcore)
                else
                    if shouldTeleportToLobby(currentLevel, currentDungeon, currentDifficulty) then
                        game:GetService("TeleportService"):Teleport(2414851778)
                    end
                end
            end
        end)()
    end
end)

if isAutoDungeon then
    coroutine.wrap(function()
        while isAutoDungeon do
            wait(0.1)
            local currentLevel = game.Players.LocalPlayer.leaderstats.Level.Value
            local currentPlaceID = game.PlaceId
            local currentDungeon, currentDifficulty = getDungeonAndDifficultyForLevel(currentLevel)
            
            if currentPlaceID == 2414851778 then
                saveCurrentDungeon(currentDungeon)
                saveCurrentDifficulty(currentDifficulty)
                createDungeon(currentDungeon, currentDifficulty, useHardcore)
            else
                if shouldTeleportToLobby(currentLevel, currentDungeon, currentDifficulty) then
                    game:GetService("TeleportService"):Teleport(2414851778)
                end
            end
        end
    end)()
end

local webhookButton = createButton(frame, "Webhook", UDim2.new(0.03, 0, 0, 5))
webhookButton.Size = UDim2.new(0.2, 0, 0, 25)

local webhookFrame = Instance.new("Frame")
webhookFrame.Size = UDim2.new(0, 200, 0, 160)
webhookFrame.Position = UDim2.new(1.02, 0, 0, 0)
webhookFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
webhookFrame.BackgroundTransparency = 0.5
webhookFrame.Visible = false
webhookFrame.Parent = frame
Instance.new("UICorner", webhookFrame).CornerRadius = UDim.new(0, 8)

local webhookInput = Instance.new("TextBox")
webhookInput.Size = UDim2.new(0.9, 0, 0, 30)
webhookInput.Position = UDim2.new(0.05, 0, 0.1, 0)
webhookInput.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
webhookInput.BackgroundTransparency = 0.5
webhookInput.TextColor3 = Color3.fromRGB(255, 255, 255)
webhookInput.PlaceholderText = "Enter Webhook URL"
webhookInput.Text = ""
webhookInput.Parent = webhookFrame
Instance.new("UICorner", webhookInput).CornerRadius = UDim.new(0, 8)

local pingLegButton = Instance.new("TextButton")
pingLegButton.Size = UDim2.new(0.9, 0, 0, 25)
pingLegButton.Position = UDim2.new(0.05, 0, 0.4, 0)
pingLegButton.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
pingLegButton.BackgroundTransparency = 0.5
pingLegButton.TextColor3 = Color3.fromRGB(255, 255, 255)
pingLegButton.Text = "Ping on Legendary"
pingLegButton.Parent = webhookFrame
Instance.new("UICorner", pingLegButton).CornerRadius = UDim.new(0, 8)

local pingUltButton = Instance.new("TextButton")
pingUltButton.Size = UDim2.new(0.9, 0, 0, 25)
pingUltButton.Position = UDim2.new(0.05, 0, 0.6, 0)
pingUltButton.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
pingUltButton.BackgroundTransparency = 0.5
pingUltButton.TextColor3 = Color3.fromRGB(255, 255, 255)
pingUltButton.Text = "Ping on Ultimate"
pingUltButton.Parent = webhookFrame
Instance.new("UICorner", pingUltButton).CornerRadius = UDim.new(0, 8)

local startWebhookButton = Instance.new("TextButton")
startWebhookButton.Size = UDim2.new(0.9, 0, 0, 30)
startWebhookButton.Position = UDim2.new(0.05, 0, 0.8, 0)
startWebhookButton.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
startWebhookButton.BackgroundTransparency = 0.5
startWebhookButton.TextColor3 = Color3.fromRGB(255, 255, 255)
startWebhookButton.Text = "Start Webhook"
startWebhookButton.Parent = webhookFrame
Instance.new("UICorner", startWebhookButton).CornerRadius = UDim.new(0, 8)

local HttpService = game:GetService("HttpService")
local savePath = "kisave/inventory.json"

local pingSettings = {
   legendary = false,
   ultimate = false
}

local function formatNumber(num)
   local suffixes = {"", "K", "M", "B", "T", "Qa", "Qi", "Sx", "Sp", "Oc", "No", "Dc"}
   local suffixIndex = 1
   while num >= 1000 and suffixIndex < #suffixes do
       num = num / 1000
       suffixIndex = suffixIndex + 1
   end
   return string.format("%.1f%s", num, suffixes[suffixIndex])
end

local function getRarityEmoji(rarity)
   local emojis = {
       ["common"] = "",
       ["uncommon"] = "",
       ["rare"] = "",
       ["epic"] = "",
       ["legendary"] = "",
       ["ultimate"] = ""
   }
   return emojis[string.lower(rarity)] or ""
end

local function saveSettings()
   local saveFolder = "kisave"
   if not isfolder(saveFolder) then makefolder(saveFolder) end
   writefile(saveFolder .. "/ping_settings.json", HttpService:JSONEncode(pingSettings))
   writefile(saveFolder .. "/webhook_url.txt", webhookInput.Text)
end

local function loadSettings()
   local saveFolder, settingsFile = "kisave", "kisave/ping_settings.json"
   if isfolder(saveFolder) and isfile(settingsFile) then
       pingSettings = HttpService:JSONDecode(readfile(settingsFile))
       pingLegButton.BackgroundColor3 = pingSettings.legendary and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(45, 45, 45)
       pingUltButton.BackgroundColor3 = pingSettings.ultimate and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(45, 45, 45)
   end
   local webhookFile = "kisave/webhook_url.txt"
   if isfolder(saveFolder) and isfile(webhookFile) then
       return readfile(webhookFile)
   end
   return ""
end

webhookInput.Text = loadSettings()

pingLegButton.MouseButton1Click:Connect(function()
   pingSettings.legendary = not pingSettings.legendary
   pingLegButton.BackgroundColor3 = pingSettings.legendary and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(45, 45, 45)
   saveSettings()
end)

pingUltButton.MouseButton1Click:Connect(function()
   pingSettings.ultimate = not pingSettings.ultimate
   pingUltButton.BackgroundColor3 = pingSettings.ultimate and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(45, 45, 45)
   saveSettings()
end)

local function getPlayerStats()
   local player = game.Players.LocalPlayer
   local leaderstats = player:WaitForChild("leaderstats")
   local gold = leaderstats:WaitForChild("Gold").Value
   local level = leaderstats:WaitForChild("Level").Value
   local xp = player:WaitForChild("XP").Value
   local xpNeeded = player:WaitForChild("XPNeeded").Value
   return {
       gold = formatNumber(gold),
       level = level,
       xp = formatNumber(xp),
       xpNeeded = formatNumber(xpNeeded)
   }
end

local function startWebhookMonitoring(webhookUrl)
   if webhookUrl == "" then return end

   local function getCurrentInventory()
       local inventory = {
           items = {},
           totalCount = 0,
           itemData = {}
       }
       
       local frame = game:GetService("Players").LocalPlayer.PlayerGui:WaitForChild("InventoryUi").Main.Display.Gear.ItemScrollingFrame
       
       for _, button in pairs(frame:GetChildren()) do
           if button:IsA("TextButton") then
               local itemName = button.Name
               local rarity = button:GetAttribute("Rarity")
               local level = button:GetAttribute("Level")
               local fullName = string.format("%s [Lvl %d] (%s)", itemName, level, rarity)
               table.insert(inventory.items, fullName)
               inventory.totalCount = inventory.totalCount + 1
               inventory.itemData[fullName] = (inventory.itemData[fullName] or 0) + 1
           end
       end
       return inventory
   end

   local function formatItems(itemData)
       local formatted = {}
       for name, count in pairs(itemData) do
           if count > 1 then
               table.insert(formatted, name .. " x" .. count)
           else
               table.insert(formatted, name)
           end
       end
       return table.concat(formatted, "\n")
   end

   local function saveInventory(inventory)
       writefile(savePath, HttpService:JSONEncode(inventory))
   end

   local function loadSavedInventory()
       if isfile(savePath) then
           return HttpService:JSONDecode(readfile(savePath))
       end
       return {items = {}, totalCount = 0, itemData = {}}
   end

local function sendWebhook(title, description, fields, shouldPing)
    local player = game.Players.LocalPlayer
    local stats = getPlayerStats()
    local playerInfo = string.format("%s (%s)\n Gold: %s\n Level: %d\n XP: %s / %s",
        player.Name, player.DisplayName, stats.gold, stats.level, stats.xp, stats.xpNeeded)

    local shouldPingEveryone = false
    if shouldPing then
        for _, field in ipairs(fields) do
            if field.name == " New Items" then
                local originalValue = field.value
                if pingSettings.legendary and originalValue:find("%(legendary%)") then
                    shouldPingEveryone = true
                end
                if pingSettings.ultimate and originalValue:find("%(ultimate%)") then
                    shouldPingEveryone = true
                end
            end
        end
    end

    for _, field in ipairs(fields) do
        if field.name == " New Items" then
            field.value = field.value:gsub("(%[Lvl (%d+)%]) %((%w+)%)", function(full, level, rarity)
                return string.format("[Lvl %s] (%s %s)", level, getRarityEmoji(rarity), rarity)
            end)
        end
    end

    local embed = {
        title = " " .. title,
        description = " Player Info:\n" .. playerInfo .. "\n\n" .. description,
        fields = fields,
        color = 5814783,
        timestamp = DateTime.now():ToIsoDate(),
        footer = {
            text = "Kinayo Scripts"
        }
    }

    local data = {
        content = shouldPingEveryone and "@everyone" or "",
        embeds = {embed}
    }

    request({
        Url = webhookUrl,
        Method = "POST",
        Headers = {["Content-Type"] = "application/json"},
        Body = HttpService:JSONEncode(data)
    })
end

   local function checkNewItems()
       local current = getCurrentInventory()
       local saved = loadSavedInventory()
       local newItems = {}
       local newItemsCount = 0
       local hasRareItems = false
       
       for itemName, count in pairs(current.itemData) do
           local savedCount = saved.itemData[itemName] or 0
           if count > savedCount then
               newItems[itemName] = count - savedCount
               newItemsCount = newItemsCount + (count - savedCount)
               if itemName:find("%(legendary%)") or itemName:find("%(ultimate%)") then
                   hasRareItems = true
               end
           end
       end
       
       if next(newItems) then
           local fields = {
               {
                   name = " New Items",
                   value = formatItems(newItems),
                   inline = false
               },
               {
                   name = " Statistics",
                   value = string.format("New items: %d\nTotal items: %d", newItemsCount, current.totalCount),
                   inline = false
               }
           }
           
           local description = hasRareItems and " Rare items have been found!" or " New items have been found!"
           sendWebhook("Inventory Update", description, fields, hasRareItems)
       else
           sendWebhook("Script Status", " Monitoring inventory for changes...", {
               {
                   name = " Current Status",
                   value = "No new items found since last check",
                   inline = false
               }
           }, false)
       end
       
       saveInventory(current)
   end

   if not isfolder("kisave") then
       makefolder("kisave")
   end

   if not isfile(savePath) then
       local initial = getCurrentInventory()
       saveInventory(initial)
       sendWebhook("Script Status", " Script started and inventory saved!", {}, false)
   else
       checkNewItems()
   end
end

webhookButton.MouseButton1Click:Connect(function()
   webhookFrame.Visible = not webhookFrame.Visible
end)

startWebhookButton.MouseButton1Click:Connect(function()
   local webhookUrl = webhookInput.Text
   if webhookUrl ~= "" then
       saveSettings()
       webhookFrame.Visible = false
       showNotification("Webhook", "Webhook URL saved", 3)
       startWebhookMonitoring(webhookUrl)
   else
       showNotification("Error", "Please enter a webhook URL", 3)
   end
end)

local savedWebhookUrl = loadSettings()
if savedWebhookUrl ~= "" then
   startWebhookMonitoring(savedWebhookUrl)
end

local TeleportService = game:GetService('TeleportService')
local Players = game:GetService('Players')
local LocalPlayer = Players.LocalPlayer

local function setupReconnect()
    repeat wait() until game.CoreGui:FindFirstChild('RobloxPromptGui')
    
    local promptGui = game.CoreGui.RobloxPromptGui.promptOverlay
    
    promptGui.ChildAdded:Connect(function(prompt)
        if prompt.Name == 'ErrorPrompt' or 
           prompt.Name == 'DisconnectPrompt' or 
           prompt.Name == 'KickPrompt' or
           prompt.Name == 'ReconnectPrompt' then
            repeat
                TeleportService:Teleport(2414851778)
                wait(2)
            until false
        end
    end)
end

game:GetService("GuiService").ErrorMessageChanged:Connect(function()
    wait(1)
    TeleportService:Teleport(2414851778)
end)

setupReconnect()

end

local function verifyKey(key)
    local hwid = getHWID()
    
    local success, response = pcall(function()
        local url = API_URL .. "/api/verify?key=" .. HttpService:UrlEncode(key) .. "&hwid=" .. HttpService:UrlEncode(hwid)
        return fRequest({
            Url = url,
            Method = "GET"
        })
    end)
    
    if not success then
        onMessage("Connection error! Try using VPN")
        return false
    end
    
    if not response.Success or response.StatusCode ~= 200 then
        onMessage("Cannot reach server! Try using VPN")
        return false
    end
    
    local parseSuccess, data = pcall(function()
        return HttpService:JSONDecode(response.Body)
    end)
    
    if parseSuccess and data then
        if data.status == "success" then
            return true
        elseif data.status == "hwid_mismatch" then
            onMessage("Key is bound to another device!")
            return false
        elseif data.status == "invalid" then
            onMessage("Invalid key! " .. (data.message or ""))
            return false
        else
            onMessage("Error: " .. (data.message or "Unknown error"))
            return false
        end
    else
        onMessage("Server response error! Try again later")
        return false
    end
end

local function checkSavedKey()
    if scriptLoaded or invalidKeySaved then return false end
    
    if isfile("kinayosave/kinayokey.txt") then
        local savedKey = readfile("kinayosave/kinayokey.txt")
        local isValid = verifyKey(savedKey)
        
        if isValid then
            scriptLoaded = true
            onMessage("Saved key is valid. Starting script...")
            loadMainScript()
            return true
        else
            invalidKeySaved = true
        end
    end
    return false
end

task.spawn(function()
    while wait(0.5) do 
        if checkSavedKey() then
            break
        end
    end
end)

VerifyButton.MouseButton1Click:Connect(function()
    local inputKey = KeyBox.Text:gsub("%s+", "")
    if inputKey == "" then
        onMessage("Please enter a key!")
        return
    end
    
    local isValid = verifyKey(inputKey)
    
    if isValid then
        scriptLoaded = true
        writefile("kinayosave/kinayokey.txt", inputKey)
        onMessage("Key verified successfully!")
        loadMainScript()
    end
end)
